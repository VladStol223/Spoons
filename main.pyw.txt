#Vladislav Stolbennikov
#8/7/2024
#App Demo for Spoons

'''
New pages to add:

Total pages:
1.) Add Spoons
2.) Add Tasks
3.) Complete Tasks
4.) Remove Tasks
5.) Calendar
6.) daily schedule
7.) Settings

To do:
4.) Add a "today's schedule" page, where you can see all of the tasks you set for that day, in a specific time. When you don't have any tasks set for that day but you want to get ahead, 
    the daily schedule should auto-populate with the the tasks that have the closest due date.
'''
from os import system, name
from datetime import datetime
from datetime import timedelta

import time
import pygame
import sys
import calendar
import json

pygame.init()

screen = pygame.display.set_mode((800, 600))
pygame.display.set_caption("Spoons App")

big_font = pygame.font.Font(None, 40)
font = pygame.font.Font(None, 36)
small_font = pygame.font.Font(None, 28)
smaller_font = pygame.font.Font(None, 20)

WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GREEN = (0, 255, 0)
RED = (255, 0, 0)
LIGHT_GRAY = (200, 200, 200)
CAMEL = (193, 154, 107)
LIME_GREEN = (50,205,50)
GOLD = (255,233,0)
BLUE = (0,0,255)
LIGHT_BLUE = (126, 249, 255)
DARK_GRAY = (100, 100, 100)
r = 193
g = 154
b = 107

dropdown_colors_list = [
    ["background",CAMEL],
    ["done button" ,LIME_GREEN],
    ["folder choices" ,BLUE],
    ["chosen folder" ,GOLD],
    ["choose folder C", BLUE],
    ["complete task", LIME_GREEN],
    ["choose folder R",BLUE],
    ["remove task",LIME_GREEN]
]
dropdown_hub_colors_list = [
    ["add spoons", GOLD],
    ["add tasks", GREEN],
    ["complete tasks", LIME_GREEN],
    ["remove tasks", RED],
    ["daily schedule", LIGHT_BLUE],
    ["calendar", BLUE],
    ["settings", DARK_GRAY]
]
dropdown_calendar_colors_list = [
    ["current day", CAMEL],
    ["cur day header", GOLD],
    ["previous day", LIGHT_BLUE],
    ["pre day header", BLUE],
    ["next day", LIGHT_BLUE],
    ["next day header", BLUE],
    ["month pre/next", CAMEL],
    ["homework fol", BLUE],
    ["chores fol", GREEN],
    ["work fol", RED],
    ["misc fol", GOLD]
]

class_schedule = {
    "Monday": [
        {"name": "Computing for Engineers", "start_time": [0, 8, 2, 5], "end_time": [0, 9, 1, 5]},
        {"name": "GT Transfer Seminar", "start_time": [1, 1, 0, 0], "end_time": [1, 1, 5, 0]},
        {"name": "Intro to Engr Graphics", "start_time": [1, 2, 3, 0], "end_time": [1, 3, 2, 0]},
        {"name": "Prin of Macroecon", "start_time": [1, 7, 0, 0], "end_time": [1, 8, 1, 0]}
    ],
    "Tuesday": [
        {"name": "Statics", "start_time": [0, 8, 2, 5], "end_time": [0, 9, 1, 5]},
    ],
    "Wednesday": [
        {"name": "Computing for Engineers", "start_time": [0, 8, 2, 5], "end_time": [0, 9, 1, 5]},
        {"name": "Intro to Engr Graphics", "start_time": [1, 2, 3, 0], "end_time": [1, 3, 2, 0]},
        {"name": "Prin of Macroecon", "start_time": [1, 7, 0, 0], "end_time": [1, 8, 1, 0]},
        {"name": "Computing Recitations", "start_time": [1, 8, 3, 0], "end_time": [1, 9, 4, 0]}
    ],
    "Thursday": [
        {"name": "Statics", "start_time": [0, 8, 2, 5], "end_time": [0, 9, 1, 5]},
        {"name": "Intro to Engr Graphics Lab", "start_time": [1, 2, 3, 0], "end_time": [1, 5, 1, 0]}
    ],
    "Friday": [
        {"name": "Computing for Engineers", "start_time": [0, 8, 2, 5], "end_time": [0, 9, 1, 5]},
        {"name": "Wellness", "start_time": [1, 1, 0, 0], "end_time": [1, 2, 5, 0]}
    ]
}
spoons = 0
current_task = ""
current_spoons = 0
homework_tasks_list = []
chores_tasks_list = []
work_tasks_list = []
misc_tasks_list = []
task_buttons_homework = []
task_buttons_chores = []
task_buttons_work = []
task_buttons_misc = []
input_active = False
months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
current_time = datetime.now()
previous_month = current_time.month
current_month = current_time.month
task_month = current_month
previous_day = current_time.strftime('%d')
current_day = current_time.strftime('%d')
displayed_month = datetime.now().month
displayed_year = datetime.now().year
task_day = current_day
hub_buttons_showing = False

# Creating input boxes/ buttons
# Spoon input
spoon_amount_input_box = pygame.Rect(375, 90, 50, 50)
spoon_done_button = pygame.Rect(300, 175, 200, 50)
short_rest_button = pygame.Rect(40, 250, 220, 50)
half_rest_button = pygame.Rect(290, 250, 220, 50)
full_rest_button = pygame.Rect(540, 250, 220, 50)
monday_input_box = 1
tuesday_input_box = 1
wednesday_input_box = 1
thursday_input_box = 1
friday_input_box = 1
saturday_input_box = 1
sunday_input_box = 1
# Task Input
task_input_box = pygame.Rect(250, 195, 300, 50)
spoon_input_box = pygame.Rect(375, 420, 50, 50)
done_button = pygame.Rect(300, 500, 200, 50)
time_toggle_button = pygame.Rect(0,50,40,40)
start_time_input_box = pygame.Rect(450, 305, 80, 50)
end_time_input_box = pygame.Rect(560, 305, 80, 50)
# Define both sets of due date input boxes (unshifted and shifted)
month_input_box_normal = pygame.Rect(280, 305, 160, 50)
month_up_button_normal = pygame.Rect(420, 310, 15, 15)
month_down_button_normal = pygame.Rect(420, 335, 15, 15)
day_input_box_normal = pygame.Rect(465, 305, 70, 50)
day_up_button_normal = pygame.Rect(515, 310, 15, 15)
day_down_button_normal = pygame.Rect(515, 335, 15, 15)
# Shifted positions for due date inputs when toggle is on
month_input_box_shifted = pygame.Rect(180, 305, 170, 50)
month_up_button_shifted = pygame.Rect(330, 310, 15, 15)
month_down_button_shifted = pygame.Rect(330, 335, 15, 15)
day_input_box_shifted = pygame.Rect(365, 305, 70, 50)
day_up_button_shifted = pygame.Rect(415, 310, 15, 15)
day_down_button_shifted = pygame.Rect(415, 335, 15, 15)
# hub buttons
hub_add_spoons = pygame.Rect(20,58,210,50)
hub_add_task = pygame.Rect(20,128,210,50)
hub_complete_task = pygame.Rect(20,198,210,50)
hub_remove_task = pygame.Rect(20,268,210,50)
hub_daily_schedule = pygame.Rect(20,338,210,50)
hub_calendar = pygame.Rect(20,408,210,50)
hub_settings = pygame.Rect(20,478,210,50)
hub_toggle = pygame.Rect(0,0,40,40)
hub_menu1 = pygame.Rect(10,10,20,4)
hub_menu2 = pygame.Rect(10,18,20,4)
hub_menu2_open = pygame.Rect(15,18,15,4)
hub_menu3 = pygame.Rect(10,26,20,4)
hub_cover = pygame.Rect(1,1,250,600)
#tool tips
add_spoons_tool_tip_rect = pygame.Rect(250,30,300,200)
add_task_tool_tip_rect = pygame.Rect(250,100,300,200)
complete_task_tool_tip_rect = pygame.Rect(250,170,300,200)
remove_task_tool_tip_rect = pygame.Rect(250,240,300,200)
daily_schedule_tool_tip_rect = pygame.Rect(250,310,300,200)
calendar_tool_tip_rect = pygame.Rect(250,380,300,200)
settings_tool_tip_rect = pygame.Rect(250,380,300,200)
# choosing task folder buttons
homework_tasks = pygame.Rect(167,85,100,38)
homework_tasks_big = pygame.Rect(157,82,120,44)
chores_tasks = pygame.Rect(287,85,100,38)
chores_tasks_big = pygame.Rect(277,82,120,44)
work_tasks = pygame.Rect(407,85,100,38)
work_tasks_big = pygame.Rect(397,82,120,44)
misc_tasks = pygame.Rect(527,85,100,38)
misc_tasks_big = pygame.Rect(517,82,120,44)
# complete task hub buttons
complete_homework_tasks = pygame.Rect(25,100,400,75)
complete_chores_tasks = pygame.Rect(25,200,400,75)
complete_work_tasks = pygame.Rect(25,300,400,75)
complete_misc_tasks = pygame.Rect(25,400,400,75)
# remove task hub buttons
remove_homework_tasks = pygame.Rect(195,100,400,75)
remove_chores_tasks = pygame.Rect(195,200,400,75)
remove_work_tasks = pygame.Rect(195,300,400,75)
remove_misc_tasks = pygame.Rect(195,400,400,75)
remove_all_tasks_button = pygame.Rect(195,535,400,35)
#Scroll bar
scroll_bar_body = pygame.Rect(10,100,30,450)
scroll_bar_up_button = pygame.Rect(12,102,26,32)
scroll_bar_down_button = pygame.Rect(12,516,26,32)
# Loading all Images
spoon_image = pygame.image.load("spoon.png")
spoon_image = pygame.transform.scale(spoon_image, (33, 33))
battery_image = pygame.image.load("green battery.png")
battery_image = pygame.transform.scale(battery_image, (33, 33))
star_image = pygame.image.load("star.png")
star_image = pygame.transform.scale(star_image, (33, 33))
potion_image = pygame.image.load("potion.png")
potion_image = pygame.transform.scale(potion_image, (33, 33))
spoon_bracket_image = pygame.image.load("spoon_bracket.png")
spoon_bracket_image = pygame.transform.scale(spoon_bracket_image, (33, 33))
color_wheel = pygame.image.load("color_wheel.png").convert_alpha()
color_wheel = pygame.transform.smoothscale(color_wheel, (200, 200))
color_wheel_rect = color_wheel.get_rect(center=(400, 200))
#calendar page
previous_month_button = pygame.Rect(500,25,27,27)
next_month_button = pygame.Rect(538,25,27,27)
#settings page
tool_tip_toggle = pygame.Rect(170, 30, 23, 23)
dropdown_colors_rect = pygame.Rect(50, 100, 230, 40)
dropdown_colors_open = False
dropdown_colors_hub_rect = pygame.Rect(50, 200, 230, 40)
dropdown_colors_hub_open = False
dropdown_colors_calendar_rect = pygame.Rect(50, 300, 230, 40)
dropdown_colors_calendar_open = False
spoon_name_input_box = pygame.Rect(300, 338, 200, 40)
button_chosen = "background"
hub_button_chosen = ""
calendar_button_chosen = ""
spoon_name_input = ""
aquatic_theme = pygame.Rect(530, 110, 230, 40)
foresty_theme = pygame.Rect(530, 160, 230, 40)
girly_pop_theme = pygame.Rect(530, 210, 230, 40)
vampire_goth_theme = pygame.Rect(530, 260, 230, 40)
sunset_glow_theme = pygame.Rect(530, 310, 230, 40)
spoon_image_outline = pygame.Rect(310,390,35,35)
battery_image_outline = pygame.Rect(360,390,35,35)
star_image_outline = pygame.Rect(410,390,35,35)
potion_image_outline = pygame.Rect(460,390,35,35)
# daily schedule
daily_schedule_top_cover = pygame.Rect(0,0,800,40)
last_day_button = pygame.Rect(80,10,20,20)
next_day_button = pygame.Rect(720,10,20,20)

####################################################################################################################################

def draw_input_box(screen, rect, active, text):
    color = GREEN if active else LIGHT_GRAY
    pygame.draw.rect(screen, color, rect, 2)
    text_surface = font.render(str(text), True, BLACK)
    screen.blit(text_surface, (rect.x + 5, rect.y + 12))#

def draw_rounded_button(screen, rect, color, border_color, border_radius=10, border_width=2):
    pygame.draw.rect(screen, border_color, rect, border_radius=border_radius)
    inner_rect = rect.inflate(-border_width * 4, -border_width * 4)  
    pygame.draw.rect(screen, color, inner_rect, border_radius=border_radius)

def draw_spoons(screen, spoons):
    date_text = font.render(f"{current_month}/{current_day}", True, BLACK)
    screen.blit(date_text, (740, 20))
    if spoons > 0 and spoons < 17:
        spoon_text = font.render(f"{spoon_name}:", True, BLACK)
        for i in range(spoons):
            screen.blit(icon_image, (150+i*40, 15))
    elif spoons > 16:
        spoon_text = font.render(f"{spoon_name}: {spoons}", True, BLACK)
        screen.blit(icon_image, (180, 15))
    else:
        spoon_text = font.render(f"{spoon_name}: None", True, BLACK)
    screen.blit(spoon_text, (50, 20))

def draw_hub_buttons():
    global hub_buttons_showing
    hub_buttons_showing = True
    mouse_pos = pygame.mouse.get_pos()

    darker_background_color = (max(0, background_color[0] - 20), 
        max(0, background_color[1] - 20), 
        max(0, background_color[2] - 20))
    pygame.draw.rect(screen, darker_background_color, hub_cover)
    pygame.draw.rect(screen, LIGHT_GRAY, hub_toggle)
    pygame.draw.rect(screen, BLACK,hub_menu1)
    pygame.draw.rect(screen, BLACK,hub_menu2_open)
    pygame.draw.rect(screen, BLACK,hub_menu3)
    draw_rounded_button(screen, hub_add_spoons,LIGHT_GRAY if page == "input_spoons" else add_spoons_color, BLACK, 15)
    add_spoons = font.render("Add Spoons", True, BLACK)
    screen.blit(add_spoons, (50,70))
    
    draw_rounded_button(screen, hub_add_task,LIGHT_GRAY if page == "input_tasks" else add_tasks_color, BLACK, 15)
    add_task = font.render("Add Tasks", True, BLACK)
    screen.blit(add_task, (65,140))

    draw_rounded_button(screen, hub_complete_task,LIGHT_GRAY if page == "complete_tasks" else complete_tasks_color, BLACK, 15)
    complete_task = font.render("Complete Tasks", True, BLACK)
    screen.blit(complete_task, (33,210))

    draw_rounded_button(screen, hub_remove_task,LIGHT_GRAY if page == "remove_tasks" else remove_tasks_color, BLACK, 15)
    remove_task = font.render("Remove Tasks", True, BLACK)
    screen.blit(remove_task, (40,280))

    draw_rounded_button(screen, hub_daily_schedule,LIGHT_GRAY if page == "daily_schedule" else daily_schedule_color, BLACK, 15)
    remove_task = font.render("daily schedule", True, BLACK)
    screen.blit(remove_task, (40,350))

    draw_rounded_button(screen, hub_calendar,LIGHT_GRAY if page == "calendar" else calendar_color, BLACK, 15)
    remove_task = font.render("Calendar", True, BLACK)
    screen.blit(remove_task, (70,420))

    draw_rounded_button(screen, hub_settings,LIGHT_GRAY if page == "settings" else settings_color, BLACK, 15)
    remove_task = font.render("Settings", True, BLACK)
    screen.blit(remove_task, (70,490))

    if tool_tips == True:
        if hub_add_spoons.collidepoint(mouse_pos):
            draw_rounded_button(screen, add_spoons_tool_tip_rect, LIGHT_GRAY, BLACK, 5, 3)
            hover_text = f"Allows users to increase the\namount of energy, or {spoon_name}\nthey have, representing\navailable energy or capacity\nfor tasks. Users can manually\nadd {spoon_name} for themselves\nor have them be added\nautomatically."
            text_lines = hover_text.split('\n')
            y_offset = 0
            for line in text_lines:
                rendered_text = small_font.render(line, True, BLACK)
                screen.blit(rendered_text, (262, 42 + y_offset))
                y_offset += 22
        elif hub_add_task.collidepoint(mouse_pos):
            draw_rounded_button(screen, add_task_tool_tip_rect, LIGHT_GRAY, BLACK, 5, 3)
            hover_text = f"Allows users to create new \ntasks and assign them to \nspecific folders based on \ncategories such as work, \nchores, or personal projects. \nEach task can have a name, \namount of {spoon_name}, and \ndue date."
            text_lines = hover_text.split('\n')
            y_offset = 0
            for line in text_lines:
                rendered_text = small_font.render(line, True, BLACK)
                screen.blit(rendered_text, (262, 112 + y_offset))
                y_offset += 22
        elif hub_complete_task.collidepoint(mouse_pos):
            draw_rounded_button(screen, complete_task_tool_tip_rect, LIGHT_GRAY, BLACK, 5, 3)
            hover_text = f"Allows users to view a list \nof tasks that are due or \ncurrently in progress and \nmark them as completed \nonce they have been finished. \nThe interface allows users to \ntrack progress across \ndifferent areas of their life."
            text_lines = hover_text.split('\n')
            y_offset = 0
            for line in text_lines:
                rendered_text = small_font.render(line, True, BLACK)
                screen.blit(rendered_text, (262, 182 + y_offset))
                y_offset += 22
        elif hub_remove_task.collidepoint(mouse_pos):
            draw_rounded_button(screen, remove_task_tool_tip_rect, LIGHT_GRAY, BLACK, 5, 3)
            hover_text = f"Allows users to delete tasks \nthat are either completed or \nhave become obsolete. \nThis helps in keeping the \ntask lists clean and focused \non actionable items, making \na streamlined approach to \ntask management."
            text_lines = hover_text.split('\n')
            y_offset = 0
            for line in text_lines:
                rendered_text = small_font.render(line, True, BLACK)
                screen.blit(rendered_text, (262, 252 + y_offset))
                y_offset += 22
        elif hub_daily_schedule.collidepoint(mouse_pos):
            draw_rounded_button(screen, daily_schedule_tool_tip_rect, LIGHT_GRAY, BLACK, 5, 3)
            hover_text = f"Allows users to create, edit, \nand manage daily schedules \nfor various needs. This page \nsimplifies planning for trips, \nensuring that all necessary \nitems are noted down and \nthat lists can be easily \nchecked off during their day."
            text_lines = hover_text.split('\n')
            y_offset = 0
            for line in text_lines:
                rendered_text = small_font.render(line, True, BLACK)
                screen.blit(rendered_text, (262, 322 + y_offset))
                y_offset += 22
        elif hub_calendar.collidepoint(mouse_pos):
            draw_rounded_button(screen, calendar_tool_tip_rect, LIGHT_GRAY, BLACK, 5, 3)
            hover_text = f"Allows users to see what is \nplanned for each day. Color-\ncoded Task folders are \ndisplayed on their respective \ndue dates. Users can hover \nover these folders for more \ndetailed infor about the tasks \ndue on any given day."
            text_lines = hover_text.split('\n')
            y_offset = 0
            for line in text_lines:
                rendered_text = small_font.render(line, True, BLACK)
                screen.blit(rendered_text, (262, 392 + y_offset))
                y_offset += 22
        elif hub_settings.collidepoint(mouse_pos):
            draw_rounded_button(screen, settings_tool_tip_rect, LIGHT_GRAY, BLACK, 5, 3)
            hover_text = f"Allows users to customize \nthe appearance of the \nSpoons App. This includes \nchanging themes, colors, \nicons, naming schemes, and \nother personalization \noptions to match user \npreferences."
            text_lines = hover_text.split('\n')
            y_offset = 0
            for line in text_lines:
                rendered_text = small_font.render(line, True, BLACK)
                screen.blit(rendered_text, (262, 392 + y_offset))
                y_offset += 22
        else:
            None

def draw_complete_tasks_folders():
    font = pygame.font.Font(None, 25)
    draw_rounded_button(screen, homework_tasks_big if folder == "homework" else homework_tasks ,add_tasks_chosen_folder_color if folder == "homework" else add_tasks_choose_folder_color, BLACK, 15)
    homework = font.render("Homework", True, BLACK)
    screen.blit(homework, (174,95))
    draw_rounded_button(screen, chores_tasks_big if folder == "chores" else chores_tasks,add_tasks_chosen_folder_color if folder == "chores" else add_tasks_choose_folder_color, BLACK, 15)
    chores = font.render("Chores", True, BLACK)
    screen.blit(chores, (308,95))
    draw_rounded_button(screen, work_tasks_big if folder == "work" else work_tasks ,add_tasks_chosen_folder_color if folder == "work" else add_tasks_choose_folder_color, BLACK, 15)
    work = font.render("Work", True, BLACK)
    screen.blit(work, (435,95))
    draw_rounded_button(screen, misc_tasks_big if folder == "misc" else misc_tasks ,add_tasks_chosen_folder_color if folder == "misc" else add_tasks_choose_folder_color, BLACK, 15)
    misc = font.render("Misc", True, BLACK)
    screen.blit(misc, (558,95))
    font = pygame.font.Font(None, 36)#

def draw_input_spoons():
    global hub_buttons_showing, input_active

    # Draw current UI elements
    draw_rounded_button(screen, hub_toggle, LIGHT_GRAY, BLACK, 0, 2)
    pygame.draw.rect(screen, BLACK, hub_menu1)
    pygame.draw.rect(screen, BLACK, hub_menu2)
    pygame.draw.rect(screen, BLACK, hub_menu3)

    # Main spoon input box
    draw_input_box(screen, spoon_amount_input_box, input_active == "spoons", str(spoons))
    prompt = font.render("Enter Number of Spoons:", True, BLACK)
    screen.blit(prompt, (255, 50))

    # Rest buttons and labels
    draw_rounded_button(screen, spoon_done_button, done_button_color, BLACK, 15)
    done_text = font.render("Done", True, WHITE)
    screen.blit(done_text, (done_button.x + 69, done_button.y - 313))

    draw_rounded_button(screen, short_rest_button, done_button_color, BLACK, 15, 3)
    screen.blit(font.render("Short Rest", True, BLACK), (short_rest_button.x + 45, short_rest_button.y + 12))
    draw_rounded_button(screen, half_rest_button, done_button_color, BLACK, 15, 3)
    screen.blit(font.render("Half Rest", True, BLACK), (half_rest_button.x + 55, half_rest_button.y + 12))
    draw_rounded_button(screen, full_rest_button, done_button_color, BLACK, 15, 3)
    screen.blit(font.render("Full Rest", True, BLACK), (full_rest_button.x + 55, full_rest_button.y + 12))

    # Weekly spoon settings section
    days_of_week = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
    daily_spoon_inputs = {}  # Store each input box for the days of the week

    automatic_spoon_add_label = font.render("Enter number of Spoons you start off with in the morning:", True, BLACK)
    screen.blit(automatic_spoon_add_label, (80, 330))

    for i, day in enumerate(days_of_week):
        # Define the position of each day's input box
        day_input_box = pygame.Rect(40 + i * 110, 400, 50, 50)
        daily_spoon_inputs[day] = day_input_box

        # Draw the input box and label for each day
        draw_input_box(screen, day_input_box, input_active == day, str(daily_spoons.get(day, 0)))
        day_label = small_font.render(f"{day}:", True, BLACK)
        screen.blit(day_label, (35 + i * 112, 370))

    # Display hub buttons if toggle is on
    if hub_toggle.collidepoint(mouse_pos):
        hub_buttons_showing = True
        draw_hub_buttons()
    if hub_buttons_showing:
        draw_hub_buttons()
    if not hub_toggle.collidepoint(mouse_pos) and not hub_cover.collidepoint(mouse_pos):
        hub_buttons_showing = False

    return daily_spoon_inputs  # Return the dictionary to use for input handling

def draw_input_tasks():  # task name, spoons needed, done?, days till due date, date, [[H,H,M,M][H,H,M,M]]
    global hub_buttons_showing, time_toggle_on
    
    # Draw hub and existing UI elements
    draw_rounded_button(screen, hub_toggle, LIGHT_GRAY, BLACK, 0, 2)
    pygame.draw.rect(screen, BLACK, hub_menu1)
    pygame.draw.rect(screen, BLACK, hub_menu2)
    pygame.draw.rect(screen, BLACK, hub_menu3)
    
    draw_complete_tasks_folders()
    draw_spoons(screen, spoons)
    draw_input_box(screen, task_input_box, input_active, current_task)
    draw_input_box(screen, spoon_input_box, input_active, str(current_spoons))

    up_arrow = font.render(">", True, BLACK)
    down_arrow = font.render("<", True, BLACK)

    # Display the time toggle button
    draw_rounded_button(screen, time_toggle_button, RED if not time_toggle_on else GREEN, BLACK, 15)

    # Check toggle state and draw respective UI elements
    if time_toggle_on:
        # Shift due date inputs to the left
        screen.blit(font.render("Enter due date:", True, BLACK), (200, 270))
        draw_input_box(screen, month_input_box_shifted, input_active, str(months[task_month - 1]))
        draw_input_box(screen, day_input_box_shifted, input_active, task_day)
        
        # Draw time input fields for start and end time
        time_of_day_label = font.render("Enter time of day:", True, BLACK)
        screen.blit(time_of_day_label, (420, 270))
        # Format the time as HH:MM for display
        start_time_display = f"{start_time[0]}{start_time[1]}:{start_time[2]}{start_time[3]}"
        end_time_display = f"{end_time[0]}{end_time[1]}:{end_time[2]}{end_time[3]}"


        # Draw start and end time input boxes with formatted time
        draw_input_box(screen, start_time_input_box, input_active == "start_time", start_time_display)
        draw_input_box(screen, end_time_input_box, input_active == "end_time", end_time_display)
        
        pygame.draw.rect(screen, done_button_color, month_up_button_shifted)
        pygame.draw.rect(screen, done_button_color, month_down_button_shifted)
        pygame.draw.rect(screen, done_button_color, day_up_button_shifted)
        pygame.draw.rect(screen, done_button_color, day_down_button_shifted)
        screen.blit(up_arrow, (330, 303))
        screen.blit(down_arrow, (330, 328))
        screen.blit(up_arrow, (415, 303))
        screen.blit(down_arrow, (415, 328))

        # Arrow between start and end time
        screen.blit(font.render("->", True, BLACK), (start_time_input_box.x + 85, start_time_input_box.y + 8))
        time_toggle_label = small_font.render("Remove Time of Day", True, BLACK)
        screen.blit(time_toggle_label, (hub_toggle.x + hub_toggle.width + 10, hub_toggle.y + hub_toggle.height + 20))
    else:
        # Draw the normal due date prompt and input boxes
        screen.blit(font.render("Enter due date:", True, BLACK), (305, 270))
        draw_input_box(screen, month_input_box_normal, input_active, str(months[task_month - 1]))
        draw_input_box(screen, day_input_box_normal, input_active, task_day)
        pygame.draw.rect(screen, done_button_color, month_up_button_normal)
        pygame.draw.rect(screen, done_button_color, month_down_button_normal)
        pygame.draw.rect(screen, done_button_color, day_up_button_normal)
        pygame.draw.rect(screen, done_button_color, day_down_button_normal)
        screen.blit(up_arrow, (420, 303))
        screen.blit(down_arrow, (420, 328))
        screen.blit(up_arrow, (515, 303))
        screen.blit(down_arrow, (515, 328))
        time_toggle_label = small_font.render("Add Time of Day", True, BLACK)
        screen.blit(time_toggle_label, (hub_toggle.x + hub_toggle.width + 10, hub_toggle.y + hub_toggle.height + 20))

    # Display other task input prompts
    screen.blit(font.render("Enter task name:", True, BLACK), (300, 155))
    screen.blit(font.render("Enter spoons needed:", True, BLACK), (280, 380))
    draw_rounded_button(screen, done_button, done_button_color, BLACK, 15)
    screen.blit(font.render("Done", True, WHITE), (done_button.x + 69, done_button.y + 12))

    # Show hub buttons if toggle is on
    if hub_toggle.collidepoint(mouse_pos):
        hub_buttons_showing = True
    if hub_buttons_showing:
        draw_hub_buttons()
    if not hub_toggle.collidepoint(mouse_pos) and not hub_cover.collidepoint(mouse_pos):
        hub_buttons_showing = False

def draw_complete_tasks_hub():
    global hub_buttons_showing
    draw_rounded_button(screen,hub_toggle,LIGHT_GRAY,BLACK,0,2)
    pygame.draw.rect(screen, BLACK, hub_menu1)
    pygame.draw.rect(screen, BLACK, hub_menu2)
    pygame.draw.rect(screen, BLACK, hub_menu3)

    homework_tasks_list.sort(key=lambda task: (task[3]))
    chores_tasks_list.sort(key=lambda task: (task[3]))
    work_tasks_list.sort(key=lambda task: (task[3]))
    misc_tasks_list.sort(key=lambda task: (task[3]))

    homework_spoons = 0
    homework_tasks = 0
    chores_spoons = 0
    chores_tasks = 0
    work_spoons = 0
    work_tasks = 0
    misc_spoons = 0
    misc_tasks = 0
    for i, (task, spoons_needed, done, days, date, start_time, end_time) in enumerate(homework_tasks_list):
        if done == "❌":
            homework_spoons += spoons_needed
            homework_tasks += 1
    for i, (task, spoons_needed, done, days, date, start_time, end_time) in enumerate(chores_tasks_list):
        if done == "❌":
            chores_spoons += spoons_needed
            chores_tasks += 1
    for i, (task, spoons_needed, done, days, date, start_time, end_time) in enumerate(work_tasks_list):
        if done == "❌":
            work_spoons += spoons_needed
            work_tasks += 1
    for i, (task, spoons_needed, done, days, date, start_time, end_time) in enumerate(misc_tasks_list):
        if done == "❌":
            misc_spoons += spoons_needed
            misc_tasks += 1
            
    draw_spoons(screen,spoons)
    draw_rounded_button(screen,complete_homework_tasks,complete_tasks_hub_folder_color if homework_tasks_list else LIGHT_GRAY, BLACK, 15)
    homework = font.render("Homework:", True, BLACK)
    screen.blit(homework, (155,110))
    homework_info = font.render(f"{homework_spoons} spoons needed for {homework_tasks} tasks", True, BLACK)
    screen.blit(homework_info, (60,140))

    if homework_tasks_list:
        hover_text = font.render(f"{homework_tasks_list[0][0]}", True, BLACK)
        hover_text_2 = font.render(f"is due in {homework_tasks_list[0][3]} days for {homework_tasks_list[0][1]} spoons", True, BLACK)
        screen.blit(hover_text, (440, 110))
        screen.blit(hover_text_2, (440, 135))

    draw_rounded_button(screen,complete_chores_tasks,complete_tasks_hub_folder_color if chores_tasks_list else LIGHT_GRAY, BLACK, 15)
    chores = font.render("Chores:", True, BLACK)
    screen.blit(chores, (180,210))
    chores_info = font.render(f"{chores_spoons} spoons needed for {chores_tasks} tasks", True, BLACK)
    screen.blit(chores_info, (60,240))

    if chores_tasks_list:
        hover_text = font.render(f"{chores_tasks_list[0][0]}", True, BLACK)
        hover_text_2 = font.render(f"is due in {chores_tasks_list[0][3]} days for {chores_tasks_list[0][1]} spoons", True, BLACK)
        screen.blit(hover_text, (440, 210))
        screen.blit(hover_text_2, (440, 235))

    draw_rounded_button(screen,complete_work_tasks,complete_tasks_hub_folder_color if work_tasks_list else LIGHT_GRAY, BLACK, 15)
    work = font.render("Work:", True, BLACK)
    screen.blit(work, (195,310))
    work_info = font.render(f"{work_spoons} spoons needed for {work_tasks} tasks", True, BLACK)
    screen.blit(work_info, (60,340))

    if work_tasks_list:
        hover_text = font.render(f"{work_tasks_list[0][0]}", True, BLACK)
        hover_text_2 = font.render(f"is due in {work_tasks_list[0][3]} days for {work_tasks_list[0][1]} spoons", True, BLACK)
        screen.blit(hover_text, (440, 310))
        screen.blit(hover_text_2, (440, 335))

    draw_rounded_button(screen,complete_misc_tasks,complete_tasks_hub_folder_color if misc_tasks_list else LIGHT_GRAY, BLACK, 15)
    misc = font.render("Misc:", True, BLACK)
    screen.blit(misc, (195,410))
    misc_info = font.render(f"{misc_spoons} spoons needed for {misc_tasks} tasks", True, BLACK)
    screen.blit(misc_info, (60,440))

    if misc_tasks_list:
        hover_text = font.render(f"{misc_tasks_list[0][0]}", True, BLACK)
        hover_text_2 = font.render(f"is due in {misc_tasks_list[0][3]} days for {misc_tasks_list[0][1]} spoons", True, BLACK)
        screen.blit(hover_text, (440, 410))
        screen.blit(hover_text_2, (440, 435))

    
    if hub_toggle.collidepoint(mouse_pos):
        hub_buttons_showing = True 
    if hub_buttons_showing:
        draw_hub_buttons()
    if not hub_toggle.collidepoint(mouse_pos) and not hub_cover.collidepoint(mouse_pos):
        hub_buttons_showing = False 

def draw_complete_tasks(type, task_list, buttons):
    global hub_buttons_showing, done, scroll_offset, scroll_last_update_time, scroll_limit, scroll_multiplier
    current_time = pygame.time.get_ticks() / 1000  # Current time in seconds

    draw_rounded_button(screen, hub_toggle, LIGHT_GRAY, BLACK, 0, 2)
    pygame.draw.rect(screen, BLACK, hub_menu1)
    pygame.draw.rect(screen, BLACK, hub_menu2)
    pygame.draw.rect(screen, BLACK, hub_menu3)
    if len(task_list) > 8:
        scroll_multiplier = 1
        scroll_limit = len(task_list) - 8
    else:
        scroll_multiplier = 0
        scroll_limit = 0

    # Sorts task_list so that incomplete tasks come before completed tasks
    for i in range(len(task_list)):
        for j in range(len(task_list) - 1 - i):
            if task_list[j][2] == "✅" and task_list[j + 1][2] == "❌":
                # Swap the completed task with the incomplete task
                task_list[j], task_list[j + 1] = task_list[j + 1], task_list[j]


    # Check if there are more than 8 tasks
    if len(task_list) > 8:
        # Draw scroll bar and buttons
        scroll_bar_inner_body = pygame.Rect(
        15, 136 + int((378 - int(378 * (8 / len(task_list)))) * (scroll_offset / max(1, len(task_list) - 8))),
        20, int(378 * (8 / len(task_list))) if len(task_list) > 8 else 378)
        draw_rounded_button(screen, scroll_bar_body, LIGHT_GRAY, BLACK, 0, 1)
        draw_rounded_button(screen, scroll_bar_up_button, LIGHT_GRAY, BLACK, 0, 0)
        draw_rounded_button(screen, scroll_bar_down_button, LIGHT_GRAY, BLACK, 0, 0)
        draw_rounded_button(screen, scroll_bar_inner_body, DARK_GRAY, DARK_GRAY, 0, 0)
        pygame.draw.polygon(screen, BLACK, [(20, 120), (25, 110), (30, 120)])  # Up arrow
        pygame.draw.polygon(screen, BLACK, [(20, 530), (25, 540), (30, 530)])  # Down arrow


    draw_spoons(screen, spoons)

    title = font.render(f"What {type} tasks have you completed?", True, BLACK)
    screen.blit(title, (50, 65))
    buttons.clear()
    mouse_pos = pygame.mouse.get_pos()

    # Limit the task list to show 8 tasks starting from the scroll_offset
    visible_tasks = task_list[scroll_offset:scroll_offset + 8]

    for i, (task, spoons_needed, done, days, date, start_time, end_time) in enumerate(visible_tasks):
        button = pygame.Rect(100, 100 + i * 60, 600, 50)
        draw_rounded_button(screen, button, complete_tasks_task_color if spoons >= spoons_needed else LIGHT_GRAY, BLACK, 15)
        task_text = font.render(f"{task}:", True, BLACK)
        screen.blit(task_text, (button.x + 10, button.y + 15))

        # Show warnings based on days left
        if days <= 0:
            warning_text = font.render("!!!!!", True, BLACK)
            screen.blit(warning_text, (button.x - 50, button.y + 15))
        elif days <= 1:
            warning_text = font.render("!!!", True, BLACK)
            screen.blit(warning_text, (button.x - 30, button.y + 15))
        elif days <= 3:
            warning_text = font.render("!!", True, BLACK)
            screen.blit(warning_text, (button.x - 20, button.y + 15))
        elif days <= 7:
            warning_text = font.render("!", True, BLACK)
            screen.blit(warning_text, (button.x - 10, button.y + 15))

        # Draw spoon images
        if spoons >= spoons_needed:
            for j in range(spoons_needed):
                screen.blit(spoon_bracket_image, (button.x + j * 40 + 310, button.y + 10))
                if done == "✅":
                    screen.blit(icon_image, (button.x + j * 40 + 310, button.y + 10))
        else:
            for j in range(spoons_needed):
                screen.blit(spoon_bracket_image, (button.x + j * 40 + 310, button.y + 10))
                if done == "✅":
                    screen.blit(icon_image, (button.x + j * 40 + 310, button.y + 10))

        buttons.append((button, scroll_offset + i))  # Map button to actual task index in task_list

    # Text for days left
    for button, index in buttons:
        hover_text = font.render(f"{task_list[index][3]} days", True, BLACK)
        screen.blit(hover_text, (button.x + button.width + 10, button.y))
        screen.blit(font.render("left", True, BLACK), (button.x + button.width + 10, button.y + 25))

    if hub_toggle.collidepoint(mouse_pos):
        hub_buttons_showing = True 
    if hub_buttons_showing:
        draw_hub_buttons()
    if not hub_toggle.collidepoint(mouse_pos) and not hub_cover.collidepoint(mouse_pos):
        hub_buttons_showing = False

def draw_remove_tasks(type, task_list, buttons):
    global hub_buttons_showing, scroll_offset, scroll_last_update_time, scroll_limit, scroll_multiplier
    current_time = pygame.time.get_ticks() / 1000  # Current time in seconds
    scroll_multiplier = 1
    scroll_limit = len(task_list) - 8

    draw_rounded_button(screen, hub_toggle, LIGHT_GRAY, BLACK, 0, 2)
    pygame.draw.rect(screen, BLACK, hub_menu1)
    pygame.draw.rect(screen, BLACK, hub_menu2)
    pygame.draw.rect(screen, BLACK, hub_menu3)

    draw_spoons(screen, spoons)
    title = font.render(f"What {type} tasks do you want to remove?", True, BLACK)
    screen.blit(title, (50, 65))
    buttons.clear()  # Clear the list before adding new buttons

    # Check if there are more than 8 tasks
    if len(task_list) > 8:
        # Draw scroll bar and buttons
        scroll_bar_inner_body = pygame.Rect(
            15, 136 + int((378 - int(378 * (8 / len(task_list)))) * (scroll_offset / max(1, len(task_list) - 8))),
            20, int(378 * (8 / len(task_list))) if len(task_list) > 8 else 378
        )
        draw_rounded_button(screen, scroll_bar_body, LIGHT_GRAY, BLACK, 0, 1)
        draw_rounded_button(screen, scroll_bar_up_button, LIGHT_GRAY, BLACK, 0, 0)
        draw_rounded_button(screen, scroll_bar_down_button, LIGHT_GRAY, BLACK, 0, 0)
        draw_rounded_button(screen, scroll_bar_inner_body, DARK_GRAY, DARK_GRAY, 0, 0)
        pygame.draw.polygon(screen, BLACK, [(20, 120), (25, 110), (30, 120)])  # Up arrow
        pygame.draw.polygon(screen, BLACK, [(20, 530), (25, 540), (30, 530)])  # Down arrow

    # Limit the task list to show 8 tasks starting from the scroll_offset
    visible_tasks = task_list[scroll_offset:scroll_offset + 8]

    for i, (task, spoons_needed, done, days, date, start_time, end_time) in enumerate(visible_tasks):
        button = pygame.Rect(100, 100 + i * 60, 600, 50)
        draw_rounded_button(screen, button, remove_tasks_task_color if spoons >= spoons_needed else LIGHT_GRAY, BLACK, 15)
        task_text = font.render(f"{task}:", True, BLACK)
        screen.blit(task_text, (button.x + 10, button.y + 15))

        # Draw spoon images
        for j in range(spoons_needed):
            screen.blit(spoon_bracket_image, (button.x + j * 40 + 310, button.y + 10))
            if done == "✅":
                screen.blit(icon_image, (button.x + j * 40 + 310, button.y + 10))

        buttons.append((button, scroll_offset + i))  # Map button to actual task index in task_list

    if hub_toggle.collidepoint(mouse_pos):
        hub_buttons_showing = True 
    if hub_buttons_showing:
        draw_hub_buttons()
    if not hub_toggle.collidepoint(mouse_pos) and not hub_cover.collidepoint(mouse_pos):
        hub_buttons_showing = False

def draw_remove_tasks_hub():
    global hub_buttons_showing
    draw_rounded_button(screen,hub_toggle,LIGHT_GRAY,BLACK,0,2)
    pygame.draw.rect(screen, BLACK, hub_menu1)
    pygame.draw.rect(screen, BLACK, hub_menu2)
    pygame.draw.rect(screen, BLACK, hub_menu3)

    homework_spoons = 0
    homework_tasks = 0
    chores_spoons = 0
    chores_tasks = 0
    work_spoons = 0
    work_tasks = 0
    misc_spoons = 0
    misc_tasks = 0
    for i, (task, spoons_needed, done, days, date, start_time, end_time) in enumerate(homework_tasks_list):
        homework_spoons += spoons_needed
        homework_tasks += 1
    for i, (task, spoons_needed, done, days, date, start_time, end_time) in enumerate(chores_tasks_list):
        chores_spoons += spoons_needed
        chores_tasks += 1
    for i, (task, spoons_needed, done, days, date, start_time, end_time) in enumerate(work_tasks_list):
        work_spoons += spoons_needed
        work_tasks += 1
    for i, (task, spoons_needed, done, days, date, start_time, end_time) in enumerate(misc_tasks_list):
        misc_spoons += spoons_needed
        misc_tasks += 1

    draw_spoons(screen,spoons)
    draw_rounded_button(screen,remove_homework_tasks,remove_tasks_hub_folder_color, BLACK, 15)
    homework = font.render("Homework:", True, BLACK)
    screen.blit(homework, (330,110))
    homework_info = font.render(f"{homework_spoons} spoons needed for {homework_tasks} tasks", True, BLACK)
    screen.blit(homework_info, (235,140))

    draw_rounded_button(screen,remove_chores_tasks,remove_tasks_hub_folder_color, BLACK, 15)
    chores = font.render("Chores:", True, BLACK)
    screen.blit(chores, (355,210))
    chores_info = font.render(f"{chores_spoons} spoons needed for {chores_tasks} tasks", True, BLACK)
    screen.blit(chores_info, (235,240))

    draw_rounded_button(screen,remove_work_tasks,remove_tasks_hub_folder_color, BLACK, 15)
    work = font.render("Work:", True, BLACK)
    screen.blit(work, (370,310))
    work_info = font.render(f"{work_spoons} spoons needed for {work_tasks} tasks", True, BLACK)
    screen.blit(work_info, (235,340))

    draw_rounded_button(screen,remove_misc_tasks,remove_tasks_hub_folder_color, BLACK, 15)
    misc = font.render("Misc:", True, BLACK)
    screen.blit(misc, (370,410))
    misc_info = font.render(f"{misc_spoons} spoons needed for {misc_tasks} tasks", True, BLACK)
    screen.blit(misc_info, (235,440))

    draw_rounded_button(screen,remove_all_tasks_button,remove_tasks_hub_folder_color, BLACK, 15)
    remove_all_tasks_text = font.render("Click Here to Remove All Tasks", True, BLACK)
    screen.blit(remove_all_tasks_text, (210,540))

    if hub_toggle.collidepoint(mouse_pos):
        hub_buttons_showing = True 
    if hub_buttons_showing:
        draw_hub_buttons()
    if not hub_toggle.collidepoint(mouse_pos) and not hub_cover.collidepoint(mouse_pos):
        hub_buttons_showing = False 

def handle_scroll(event):
    global scroll_offset, scroll_multiplier, scroll_limit
    if event.type == pygame.MOUSEBUTTONDOWN:
        if event.button == 4:  # Scroll up
            scroll_offset = max(scroll_offset - (1 * scroll_multiplier), 0)  # Adjust and limit the scroll offset
        elif event.button == 5:  # Scroll down
            scroll_offset = min(scroll_offset + (1 * scroll_multiplier), scroll_limit)  # Adjust and cap for 24 hours

def draw_daily_schedule():
    global hub_buttons_showing, dropdown_colors_open, current_time_indicator, scroll_offset, scroll_limit, scroll_multiplier, day_offset

    # Set up layout parameters
    start_hour = 6
    end_hour = 24
    hour_height = 90
    start_y = 50 - scroll_offset  # Adjust vertical start position by scroll offset
    left_margin = 100
    current_time = datetime.now()
    scroll_limit = ((end_hour - start_hour) * hour_height) - 550
    scroll_multiplier = 30

    # Calculate dates for the three days in view based on day_offset
    today = current_time + timedelta(days=day_offset)
    next_day = today + timedelta(days=1)
    next_next_day = today + timedelta(days=2)

    # Define x-coordinates for the columns of each day
    day_x_coords = {
        today.strftime('%A'): 100,
        next_day.strftime('%A'): 325,
        next_next_day.strftime('%A'): 550
    }

    # Draw the timeline with hours
    for hour in range(start_hour, end_hour):
        y_position = start_y + (hour - start_hour) * hour_height
        pygame.draw.line(screen, BLACK, (left_margin - 15, y_position), (left_margin + 650, y_position), 1)
        hour_text = font.render(f"{hour % 12 if hour % 12 else 12} {'AM' if hour < 12 else 'PM'}", True, BLACK)
        screen.blit(hour_text, (left_margin - 90, y_position - 10))

    # Divider lines for three columns
    pygame.draw.line(screen, BLACK, (100, 20), (100, 600), 1)
    pygame.draw.line(screen, BLACK, (325, 20), (325, 600), 1)
    pygame.draw.line(screen, BLACK, (550, 20), (550, 600), 1)

    # Display classes for each day and commute
    for day_name, classes in class_schedule.items():
        if day_name in day_x_coords:
            x_position = day_x_coords[day_name]

            # Loop through each class and calculate its position
            for class_info in classes:
                start_time, end_time = class_info["start_time"], class_info["end_time"]

                # Convert start and end time to y-coordinates
                start_hour_pos = start_time[0] * 10 + start_time[1]
                start_minute_pos = start_time[2] * 10 + start_time[3]
                end_hour_pos = end_time[0] * 10 + end_time[1]
                end_minute_pos = end_time[2] * 10 + end_time[3]

                task_start_y = start_y + ((start_hour_pos - start_hour) * hour_height) + int(hour_height * (start_minute_pos / 60))
                task_end_y = start_y + ((end_hour_pos - start_hour) * hour_height) + int(hour_height * (end_minute_pos / 60))
                task_height = task_end_y - task_start_y

                #Draw the commute block
                commute_rect = pygame.Rect(x_position + 25, task_start_y-30, 175, 30)
                draw_rounded_button(screen, commute_rect, calendar_previous_day_header_color, BLACK, 5, 3)

                rendered_line = small_font.render("commute", True, BLACK)
                screen.blit(rendered_line, (commute_rect.x + 9, commute_rect.y + 5))

                # Draw the class block
                class_rect = pygame.Rect(x_position + 25, task_start_y, 175, task_height)
                draw_rounded_button(screen, class_rect, calendar_next_day_header_color, BLACK, 5, 3)

                # Render and display the class name within the block, wrapping text if needed
                max_width = class_rect.width - 10
                words = class_info["name"].split()
                line = ""
                y_offset = 10
                for word in words:
                    # Check if adding this word would exceed the width
                    test_line = f"{line} {word}" if line else word
                    test_text = small_font.render(test_line, True, BLACK)
                    if test_text.get_width() > max_width:
                        # Render the current line and start a new one
                        rendered_line = small_font.render(line, True, BLACK)
                        screen.blit(rendered_line, (class_rect.x + 9, class_rect.y + y_offset))
                        y_offset += rendered_line.get_height() + 2
                        line = word  # Start new line with current word
                    else:
                        line = test_line  # Add word to the current line

                # Render any remaining text
                if line:
                    rendered_line = small_font.render(line, True, BLACK)
                    screen.blit(rendered_line, (class_rect.x + 9, class_rect.y + y_offset))

    # Collect tasks with valid times for today
    tasks_with_time = []
    today_date = current_time.date()
    task_colors = {
        "homework": homework_fol_color,
        "chores": chores_fol_color,
        "work": work_fol_color,
        "misc": misc_fol_color,}

    # Gather tasks with times for each category
    for task_list, task_type in zip(
        [homework_tasks_list, chores_tasks_list, work_tasks_list, misc_tasks_list],
        ["homework", "chores", "work", "misc"]
    ):
        for task in task_list:
            task_name, spoons_needed, done, days, due_date, start_time, end_time = task[:7]
            if due_date.date() == today_date and start_time != [0, 0, 0, 0] and end_time != [0, 0, 0, 0]:
                tasks_with_time.append((task, task_type))  # Store the task with its type

    # Step to draw tasks: call get_available_time_blocks, sort tasks, and allocate tasks
    #available_blocks_by_date, task_schedule = get_available_time_blocks(class_schedule)
    #sorted_tasks = sort_tasks_by_priority_and_due_date()
    #final_schedule = allocate_tasks_to_time_blocks(available_blocks_by_date, sorted_tasks)

    #draw_scheduled_tasks(final_schedule, day_x_coords, start_hour, hour_height, start_y, task_colors)

    # Draw task blocks based on the category and time
    for (task, task_type) in tasks_with_time:
        task_name, spoons_needed, done, days, due_date, start_time, end_time = task[:7]
        
        # Calculate task start and end positions based on times
        start_hour_pos = start_time[0] * 10 + start_time[1]
        start_minute_pos = start_time[2] * 10 + start_time[3]
        end_hour_pos = end_time[0] * 10 + end_time[1]
        end_minute_pos = end_time[2] * 10 + end_time[3]
        
        task_start_y = start_y + ((start_hour_pos - start_hour) * hour_height) + int(hour_height * (start_minute_pos / 60))
        task_end_y = start_y + ((end_hour_pos - start_hour) * hour_height) + int(hour_height * (end_minute_pos / 60))
        task_height = task_end_y - task_start_y

        # Draw the task block in the color of its category
        task_rect = pygame.Rect(left_margin + 25, task_start_y, 175, task_height)
        draw_rounded_button(screen, task_rect, task_colors[task_type], BLACK, 5, 3)

        # Render and display the task name within the block, wrapping text if needed
        max_width = task_rect.width - 10
        words = task_name.split()
        line = ""
        y_offset = 10
        for word in words:
            # Check if adding this word would exceed the width
            test_line = f"{line} {word}" if line else word
            test_text = small_font.render(test_line, True, BLACK)
            if test_text.get_width() > max_width:
                # Render the current line and start a new one
                rendered_line = small_font.render(line, True, BLACK)
                screen.blit(rendered_line, (task_rect.x + 5, task_rect.y + y_offset))
                y_offset += rendered_line.get_height() + 2
                line = word  # Start new line with current word
            else:
                line = test_line  # Add word to the current line

        # Render any remaining text
        if line:
            rendered_line = small_font.render(line, True, BLACK)
            screen.blit(rendered_line, (task_rect.x + 5, task_rect.y + y_offset))

    pygame.draw.rect(screen, background_color, daily_schedule_top_cover)

    # Render the formatted text for each displayed day
    current_day_text = font.render(f"{today.strftime('%a')} - {today.strftime('%d')}", True, BLACK)
    screen.blit(current_day_text, (160, 16))
    next_day_text = font.render(f"{next_day.strftime('%a')} - {next_day.strftime('%d')}", True, BLACK)
    screen.blit(next_day_text, (385, 16))
    next_next_day_text = font.render(f"{next_next_day.strftime('%a')} - {next_next_day.strftime('%d')}", True, BLACK)
    screen.blit(next_next_day_text, (610, 16))

    draw_rounded_button(screen, last_day_button, calendar_next_day_header_color, BLACK, 0, 2)
    draw_rounded_button(screen, next_day_button, calendar_previous_day_header_color, BLACK, 0, 2)

    # Draw current time indicator line if within displayed hours
    if start_hour <= current_time.hour < end_hour:
        current_time_y = start_y + (current_time.hour - start_hour) * hour_height + int(hour_height * (current_time.minute / 60))
        if 50 <= current_time_y <= 650:
            pygame.draw.line(screen, RED, (left_margin + 25, current_time_y), (left_margin + 575, current_time_y), 2)

    # Draw hub toggle
    draw_rounded_button(screen, hub_toggle, LIGHT_GRAY, BLACK, 0, 2)
    pygame.draw.rect(screen, BLACK, hub_menu1)
    pygame.draw.rect(screen, BLACK, hub_menu2)
    pygame.draw.rect(screen, BLACK, hub_menu3)

    # Draw hub buttons if active
    mouse_pos = pygame.mouse.get_pos()
    if hub_toggle.collidepoint(mouse_pos):
        hub_buttons_showing = True
        draw_hub_buttons()
    if hub_buttons_showing:
        draw_hub_buttons()
    if not hub_toggle.collidepoint(mouse_pos) and not hub_cover.collidepoint(mouse_pos):
        hub_buttons_showing = False

def get_available_time_blocks(class_schedule, start_hour=6, end_hour=24,
                              monday_task_start_time=(7, 0), tuesday_task_start_time=(7, 0),
                              wednesday_task_start_time=(7, 0), thursday_task_start_time=(7, 0),
                              friday_task_start_time=(7, 0)):
    """
    Identify available time blocks for scheduling tasks over the next 5 days.
    Also gathers tasks with pre-assigned start and end times into `task_schedule`.
    Each weekday can have a customized task start time.
    """
    dates = [datetime.today().date() + timedelta(days=i) for i in range(5)]
    available_blocks_by_date = {}
    task_schedule = {}

    # Define start times for each day
    weekday_task_start_times = {
        "Monday": monday_task_start_time,
        "Tuesday": tuesday_task_start_time,
        "Wednesday": wednesday_task_start_time,
        "Thursday": thursday_task_start_time,
        "Friday": friday_task_start_time
    }

    # Gather tasks with set times from task lists and add to task_schedule
    for task_list in [homework_tasks_list, work_tasks_list, chores_tasks_list, misc_tasks_list]:
        for task in task_list:
            task_name, spoons_needed, done, days, due_date, start_time, end_time = task[:7]
            if start_time != [0, 0, 0, 0] and end_time != [0, 0, 0, 0]:  # Only add tasks with specific times
                date_str = due_date.strftime("%Y-%m-%d")
                if date_str not in task_schedule:
                    task_schedule[date_str] = []
                task_schedule[date_str].append({"name": task_name, "start_time": start_time, "end_time": end_time})

    # Process each day in the next 5 days
    for day in dates:
        day_str = day.strftime("%Y-%m-%d")
        weekday_name = day.strftime("%A")

        # Determine the start of the day based on the specific weekday's task start time
        start_hour, start_minute = weekday_task_start_times.get(weekday_name, (6, 0))
        start_of_day = start_hour * 60 + start_minute
        end_of_day = end_hour * 60
        occupied_blocks = []

        # Include class and commute times in occupied_blocks based on the weekday
        if weekday_name in class_schedule:
            for class_info in class_schedule[weekday_name]:
                start_time = class_info["start_time"]
                end_time = class_info["end_time"]

                # Calculate start and end in minutes from the day's start
                class_start_minutes = (start_time[0] * 10 + start_time[1]) * 60 + (start_time[2] * 10 + start_time[3])
                commute_start_minutes = max(class_start_minutes - 20, start_of_day)
                class_end_minutes = (end_time[0] * 10 + end_time[1]) * 60 + (end_time[2] * 10 + end_time[3])

                occupied_blocks.append((commute_start_minutes, class_end_minutes))

        # Include tasks with set times in occupied_blocks
        for task in task_schedule.get(day_str, []):
            start_time, end_time = task["start_time"], task["end_time"]
            task_start_minutes = (start_time[0] * 10 + start_time[1]) * 60 + (start_time[2] * 10 + start_time[3])
            task_end_minutes = (end_time[0] * 10 + end_time[1]) * 60 + (end_time[2] * 10 + end_time[3])
            occupied_blocks.append((task_start_minutes, task_end_minutes))

        # Sort and check occupied_blocks
        occupied_blocks.sort()
        available_blocks = []
        last_end_time = start_of_day

        for start, end in occupied_blocks:
            if last_end_time < start:
                available_blocks.append({
                    'start_time': (last_end_time // 60, last_end_time % 60),
                    'end_time': (start // 60, start % 60)
                })
            last_end_time = max(last_end_time, end)

        # Add final available block if any
        if last_end_time < end_of_day:
            available_blocks.append({
                'start_time': (last_end_time // 60, last_end_time % 60),
                'end_time': (end_of_day // 60, end_of_day % 60)
            })

        # Store in dictionary
        available_blocks_by_date[day_str] = available_blocks
        # Debug: print the occupied and available blocks for verification
        print(f"Day: {day_str}")
        print("Occupied Blocks:", occupied_blocks)
        print("Available Blocks:", available_blocks)

    return available_blocks_by_date, task_schedule

def sort_tasks_by_priority_and_due_date():
    """
    Gather tasks from global lists, sort them by due date and type priority, and return a sorted list of tasks
    without assigned times, ready for scheduling.

    Returns:
    - sorted_tasks: list of tasks sorted by due date and priority (chore tasks prioritized, others by urgency)
    """

    # Dictionary to define task priorities
    task_priority = {
        "chores": 1,    # Highest priority
        "homework": 2,
        "work": 3,
        "misc": 4       # Lowest priority
    }

    # Collect tasks that do not yet have assigned start/end times
    unscheduled_tasks = []

    # Add unscheduled tasks from each global list
    add_unscheduled_tasks(homework_tasks_list, "homework", task_priority, unscheduled_tasks)
    add_unscheduled_tasks(chores_tasks_list, "chores", task_priority, unscheduled_tasks)
    add_unscheduled_tasks(work_tasks_list, "work", task_priority, unscheduled_tasks)
    add_unscheduled_tasks(misc_tasks_list, "misc", task_priority, unscheduled_tasks)

    # Sort the tasks by (1) due date, (2) priority (chore first), then by task type within the same due date
    sorted_tasks = sorted(
        unscheduled_tasks,
        key=lambda t: (t["due_date"], t["priority"])
    )

    return sorted_tasks

def add_unscheduled_tasks(task_list, task_type, task_priority, unscheduled_tasks):
    for task in task_list:
        task_name, spoons_needed, done, days, due_date, start_time, end_time = task[:7]
        # Only add tasks without assigned times (all zeros)
        if start_time == [0, 0, 0, 0] and end_time == [0, 0, 0, 0]:
            # Convert due_date to a datetime if it's not already
            parsed_due_date = due_date if isinstance(due_date, datetime) else datetime.strptime(due_date, "%Y-%m-%d")
            
            unscheduled_tasks.append({
                "task_name": task_name,
                "spoons_needed": spoons_needed,
                "due_date": parsed_due_date,
                "task_type": task_type,
                "priority": task_priority[task_type]
            })

def allocate_tasks_to_time_blocks(available_blocks_by_date, sorted_tasks):
    """
    Allocates tasks to available time blocks in a given schedule.
    
    Args:
    - available_blocks_by_date: Dict with keys as dates and values as lists of available time blocks for each date.
    - sorted_tasks: List of tasks sorted by due date and priority.
    
    Returns:
    - scheduled_tasks: A dictionary where each date has tasks allocated with start and end times.
    """
    scheduled_tasks = {}

    for task in sorted_tasks:
        task_name = task["task_name"]
        spoons_needed = task["spoons_needed"]
        duration_minutes = spoons_needed * 20  # Duration based on spoons (1 spoon = 20 min)
        due_date = task["due_date"].strftime("%Y-%m-%d")
        
        # Check available days starting from the task's due date
        for day, available_blocks in available_blocks_by_date.items():
            if day >= due_date:  # Only consider days from the due date onward
                for block in available_blocks:
                    block_start = block["start_time"][0] * 60 + block["start_time"][1]
                    block_end = block["end_time"][0] * 60 + block["end_time"][1]
                    block_duration = block_end - block_start
                    
                    # Check if the block can accommodate the task duration
                    if block_duration >= duration_minutes:
                        # Calculate task's start and end times within the block
                        task_start_minutes = block_start
                        task_end_minutes = task_start_minutes + duration_minutes
                        
                        # Format start and end times for the task
                        task_start_time = (task_start_minutes // 60, task_start_minutes % 60)
                        task_end_time = (task_end_minutes // 60, task_end_minutes % 60)
                        
                        # Allocate task in scheduled_tasks dictionary with correct naming
                        if day not in scheduled_tasks:
                            scheduled_tasks[day] = []
                        
                        scheduled_tasks[day].append({
                            "name": task_name,  # Use "name" instead of "task_name"
                            "start_time": task_start_time,
                            "end_time": task_end_time
                        })
                        
                        # Update the block to reflect remaining available time
                        new_block_start_minutes = task_end_minutes
                        block["start_time"] = (new_block_start_minutes // 60, new_block_start_minutes % 60)
                        
                        # Move to the next task once allocated
                        duration_minutes = 0
                        break
                
                if duration_minutes == 0:
                    break  # Move to the next task if fully allocated

    return scheduled_tasks

def draw_scheduled_tasks(final_schedule, day_x_coords, start_hour, hour_height, start_y, task_colors):
    """
    Draws scheduled tasks onto the screen based on their start and end times.
    
    Args:
    - final_schedule: Dictionary with dates as keys and lists of tasks with start and end times as values.
    - day_x_coords: Dictionary of x-coordinates for each day column (e.g., {"Monday": 100, "Tuesday": 325, "Wednesday": 550}).
    - start_hour: The hour (in 24-hour format) that the schedule starts displaying (e.g., 6 for 6:00 AM).
    - hour_height: The height in pixels for each hour on the display.
    - start_y: The starting y-coordinate for drawing the timeline.
    - task_colors: Dictionary mapping task types to their colors.
    """
    for date, tasks in final_schedule.items():
        # Calculate which day the tasks belong to based on date
        weekday_name = datetime.strptime(date, "%Y-%m-%d").strftime('%A')
        
        if weekday_name in day_x_coords:
            x_position = day_x_coords[weekday_name]
            
            for task in tasks:
                # Retrieve task details
                task_name = task["task_name"]
                start_time = task["start_time"]
                end_time = task["end_time"]
                task_type = task.get("task_type", "misc")  # Default to "misc" if type is not specified

                # Calculate task start and end positions in y-coordinates
                start_hour_pos = start_time[0]
                start_minute_pos = start_time[1]
                end_hour_pos = end_time[0]
                end_minute_pos = end_time[1]

                task_start_y = start_y + ((start_hour_pos - start_hour) * hour_height) + int(hour_height * (start_minute_pos / 60))
                task_end_y = start_y + ((end_hour_pos - start_hour) * hour_height) + int(hour_height * (end_minute_pos / 60))
                task_height = task_end_y - task_start_y

                # Draw the task block in the color of its category
                task_rect = pygame.Rect(x_position + 25, task_start_y, 175, task_height)
                task_color = task_colors.get(task_type, LIGHT_GRAY)
                draw_rounded_button(screen, task_rect, task_color, BLACK, 5, 3)

                # Render and display the task name within the block, wrapping text if needed
                max_width = task_rect.width - 10
                words = task_name.split()
                line = ""
                y_offset = 10
                for word in words:
                    # Check if adding this word would exceed the width
                    test_line = f"{line} {word}" if line else word
                    test_text = small_font.render(test_line, True, BLACK)
                    if test_text.get_width() > max_width:
                        # Render the current line and start a new one
                        rendered_line = small_font.render(line, True, BLACK)
                        screen.blit(rendered_line, (task_rect.x + 5, task_rect.y + y_offset))
                        y_offset += rendered_line.get_height() + 2
                        line = word  # Start new line with current word
                    else:
                        line = test_line  # Add word to the current line

                # Render any remaining text
                if line:
                    rendered_line = small_font.render(line, True, BLACK)
                    screen.blit(rendered_line, (task_rect.x + 5, task_rect.y + y_offset))

def draw_calendar():
    global hub_buttons_showing, displayed_month, displayed_year

    draw_rounded_button(screen, hub_toggle, LIGHT_GRAY, BLACK, 0, 2)
    pygame.draw.rect(screen, BLACK, hub_menu1)
    pygame.draw.rect(screen, BLACK, hub_menu2)
    pygame.draw.rect(screen, BLACK, hub_menu3)

    # Define the dimensions and spacing
    day_box_width = 100
    start_x = 50  # Start position for the calendar grid
    start_y = 100  # Start position for the calendar grid
    margin = 0
    top_padding = 30  # Padding from the top for day names
    days_of_week = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
    today_date = datetime.now()

    task_colors = {
        "homework": homework_fol_color,
        "chores": chores_fol_color,
        "work": work_fol_color,
        "misc": misc_fol_color
    }
    task_lists = {
        "homework": homework_tasks_list,
        "chores": chores_tasks_list,
        "work": work_tasks_list,
        "misc": misc_tasks_list
    }  

    # Get the mouse position
    mouse_pos = pygame.mouse.get_pos()
    hovered_task_folder = None
    hovered_task_folder_info = None

    # Get the first weekday of the displayed month and the number of days in the month
    first_weekday, number_of_days = calendar.monthrange(displayed_year, displayed_month)
    first_weekday = (first_weekday + 1) % 7

    # Determine if the month requires 6 rows
    total_days = first_weekday + number_of_days
    day_box_height = 80 if total_days > 35 else 95
    folder_box_height = 12 if total_days > 35 else 16

    # Draw the month name at the top
    month_text = big_font.render(calendar.month_name[displayed_month] + ' ' + str(displayed_year), True, BLACK)
    screen.blit(month_text, (570, 25))
    draw_rounded_button(screen, previous_month_button, calendar_month_color, BLACK, 2)
    draw_rounded_button(screen, next_month_button, calendar_month_color, BLACK, 2)
    month_button_text = big_font.render("<   >", True, BLACK)
    screen.blit(month_button_text, (505, 23))

    # Draw the day names
    for i, day_name in enumerate(days_of_week):
        day_text = font.render(day_name, True, BLACK)
        screen.blit(day_text, (start_x + i * (day_box_width + margin) + 25, start_y - top_padding))

    # Draw the calendar boxes
    day_number = 1
    for row in range(6):  # Maximum of 6 rows in a month
        for col in range(7):  # 7 columns for the days of the week
            # Only draw the day number if it's within the current month
            if row == 0 and col < first_weekday:  # Skip the empty days before the 1st of the month
                continue
            if day_number > number_of_days:  # Stop if we've drawn all days in the month
                break

            # Determine the x and y position for the current box
            x = start_x + col * (day_box_width + margin)
            y = start_y + row * (day_box_height + margin)
            checked_date = datetime(displayed_year, displayed_month, day_number)

            # Draw day boxes for previous, current, and future days
            if checked_date < today_date:
                pygame.draw.rect(screen, calendar_previous_day_header_color, (x, y, day_box_width, day_box_height))
                pygame.draw.rect(screen, BLACK, (x, y, day_box_width, day_box_height), 2)  # Outer border
                if total_days > 35:
                    pygame.draw.rect(screen, calendar_previous_day_color, (x, y + 14, day_box_width, day_box_height - 14))
                    pygame.draw.rect(screen, BLACK, (x, y + 14, day_box_width, day_box_height - 14), 2)  # inner Border
                else:
                    pygame.draw.rect(screen, calendar_previous_day_color, (x, y + 16, day_box_width, day_box_height - 16))
                    pygame.draw.rect(screen, BLACK, (x, y + 16, day_box_width, day_box_height - 16), 2)  # inner Border
            elif checked_date > today_date:
                pygame.draw.rect(screen, calendar_next_day_header_color, (x, y, day_box_width, day_box_height))
                pygame.draw.rect(screen, BLACK, (x, y, day_box_width, day_box_height), 2)  # Outer border
                if total_days > 35:
                    pygame.draw.rect(screen, calendar_next_day_color, (x, y + 14, day_box_width, day_box_height - 14))
                    pygame.draw.rect(screen, BLACK, (x, y + 14, day_box_width, day_box_height - 14), 2)  # inner Border
                else:
                    pygame.draw.rect(screen, calendar_next_day_color, (x, y + 16, day_box_width, day_box_height - 16))
                    pygame.draw.rect(screen, BLACK, (x, y + 16, day_box_width, day_box_height - 16), 2)  # inner Border
            if (displayed_month == datetime.now().month and displayed_year == datetime.now().year and day_number == today_date.day):
                pygame.draw.rect(screen, calendar_current_day_header_color, (x, y, day_box_width, day_box_height))
                pygame.draw.rect(screen, BLACK, (x, y, day_box_width, day_box_height), 2)  # Outer border
                if total_days > 35:
                    pygame.draw.rect(screen, calendar_current_day_color, (x, y + 14, day_box_width, day_box_height - 14))
                    pygame.draw.rect(screen, BLACK, (x, y + 14, day_box_width, day_box_height - 14), 2)  # inner Border
                else:
                    pygame.draw.rect(screen, calendar_current_day_color, (x, y + 16, day_box_width, day_box_height - 16))
                    pygame.draw.rect(screen, BLACK, (x, y + 16, day_box_width, day_box_height - 16), 2)  # inner Border

            # Draw the day number in the top right of the box
            day_text = smaller_font.render(str(day_number), True, BLACK)
            if day_number > 9:
                screen.blit(day_text, (x + day_box_width - 19, y + 2))
            else:
                screen.blit(day_text, (x + day_box_width - 11, y + 2))

            # Check for tasks on this day and draw folder boxes
            task_y_offset = y + 20  # Starting y-offset for the folder boxes

            for task_type, task_list in task_lists.items():
                # Filter tasks due on this date
                tasks_for_date = [task for task in task_list if task[4] == checked_date]
                task_count = len(tasks_for_date)

                if task_count > 0:
                    # Define folder box rect
                    folder_box_rect = pygame.Rect(x + 5, task_y_offset, day_box_width - 15, folder_box_height)
                    draw_rounded_button(screen, folder_box_rect, task_colors[task_type], BLACK, 1, 1)

                    # Check if all tasks are completed
                    all_completed = all(task[2] == "✅" for task in tasks_for_date)

                    # Check if mouse is hovering over this folder box
                    if folder_box_rect.collidepoint(mouse_pos):
                        hovered_task_folder = task_type
                        hovered_task_folder_info = {
                            "folder_name": task_type,
                            "task_count": task_count,
                            "task_details": tasks_for_date,
                            "hover_position": (x, y),
                            "column": col
                        }

                    # Draw the task count text with strike-through if all completed
                    task_text = smaller_font.render(f"{task_count} task" if task_count == 1 else f"{task_count} tasks", True, BLACK)
                    screen.blit(task_text, (x + 10, task_y_offset + 1))
                    if all_completed:
                        pygame.draw.line(screen, BLACK, (x + 10, task_y_offset + 10), (x + 50, task_y_offset + 5), 2)

                    # Move down for the next folder box
                    task_y_offset += folder_box_height + 2

            # Move to the next day
            day_number += 1

        # Stop if we've drawn all days in the month
        if day_number > number_of_days:
            break

    # Draw the hover box with task details if hovering over a folder
    if hovered_task_folder_info:
        hover_x, hover_y = hovered_task_folder_info['hover_position']
        if hovered_task_folder_info["column"] <= 3:
            hover_rect = pygame.Rect(hover_x + day_box_width, hover_y, day_box_width * 3, day_box_height)
        else:
            hover_rect = pygame.Rect(hover_x - (day_box_width * 3), hover_y, day_box_width * 3, day_box_height)

        pygame.draw.rect(screen, calendar_current_day_color, hover_rect)
        pygame.draw.rect(screen, BLACK, hover_rect, 2)

        # Display folder name and task details with strike-through if completed
        hover_text_y = hover_y - 5
        folder_name_text = font.render(hovered_task_folder_info["folder_name"], True, BLACK)
        screen.blit(folder_name_text, (hover_rect.x + 5, hover_text_y + 8))
        underline = pygame.Rect(hover_rect.x + 5, hover_text_y + 30, 100, 3)
        draw_rounded_button(screen, underline, BLACK, 1, 0)

        hover_text_y += 20
        for task in hovered_task_folder_info["task_details"]:
            task_name_text = smaller_font.render(f"{task[1]} spoons for {task[0]}", True, BLACK)
            screen.blit(task_name_text, (hover_rect.x + 5, hover_text_y + 15))
            
            # Calculate the width of the text for the strike-through line
            text_width = task_name_text.get_width()
            
            if task[2] == "✅":  # If the task is marked as completed
                pygame.draw.line(screen, BLACK, (hover_rect.x + 5, hover_text_y + 23), (hover_rect.x + 5 + text_width, hover_text_y + 18), 2)
            hover_text_y += 15


    # Draw hub buttons if they are visible
    if hub_toggle.collidepoint(mouse_pos):
        hub_buttons_showing = True
        draw_hub_buttons()
    if hub_buttons_showing:
        draw_hub_buttons()
    if not hub_toggle.collidepoint(mouse_pos) and not hub_cover.collidepoint(mouse_pos):
        hub_buttons_showing = False

def draw_settings():
    global hub_buttons_showing
    global dropdown_colors_open
    global dropdown_colors_hub_open
    draw_rounded_button(screen,hub_toggle,LIGHT_GRAY,BLACK,0,2)
    pygame.draw.rect(screen, BLACK, hub_menu1)
    pygame.draw.rect(screen, BLACK, hub_menu2)
    pygame.draw.rect(screen, BLACK, hub_menu3)

    tool_tips_text = font.render("Tool Tips:", True, BLACK)
    screen.blit(tool_tips_text, (50,30))

    draw_rounded_button(screen,tool_tip_toggle,GREEN if tool_tips == True else RED,BLACK,2,2)

    draw_rounded_button(screen,spoon_image_outline,background_color,GREEN if icon_image == spoon_image else BLACK,2,2)
    screen.blit(spoon_image, (310, 390))
    draw_rounded_button(screen,battery_image_outline,background_color,GREEN if icon_image == battery_image else BLACK,2,2)
    screen.blit(battery_image, (360, 390))
    draw_rounded_button(screen,star_image_outline,background_color,GREEN if icon_image == star_image else BLACK,2,2)
    screen.blit(star_image, (410, 390))
    draw_rounded_button(screen,potion_image_outline,background_color,GREEN if icon_image == potion_image else BLACK,2,2)
    screen.blit(potion_image, (460, 390))

    pygame.draw.rect(screen, LIGHT_GRAY if not input_active == "spoon_name" else GREEN, spoon_name_input_box, 2)
    spoon_name_text = font.render(spoon_name_input, True, BLACK)
    screen.blit(spoon_name_text, (spoon_name_input_box.x + 5, spoon_name_input_box.y + 5))
    icon_prompt = font.render("Enter icon name:", True, BLACK)
    screen.blit(icon_prompt, (300, 310))

    choose_color_text = font.render("Button/Background:", True, BLACK)
    screen.blit(choose_color_text, (50, 70))
    draw_rounded_button(screen, dropdown_colors_rect, LIGHT_GRAY, BLACK, 1)
    v_text = font.render("v", True, BLACK)
    screen.blit(v_text, (250, 108))

    choose_button_text = font.render(button_chosen, True, BLACK)
    screen.blit(choose_button_text, (60, 108)) 

    choose_hub_color_text = font.render("Hub Buttons:", True, BLACK)
    screen.blit(choose_hub_color_text, (50, 170))
    draw_rounded_button(screen, dropdown_colors_hub_rect, LIGHT_GRAY, BLACK, 1)
    v_text = font.render("v", True, BLACK)
    screen.blit(v_text, (250, 208))

    choose_button_text = font.render(hub_button_chosen, True, BLACK)
    screen.blit(choose_button_text, (60, 208)) 

    choose_calendar_color_text = font.render("Calendar colors:", True, BLACK)
    screen.blit(choose_calendar_color_text, (50, 270))
    draw_rounded_button(screen, dropdown_colors_calendar_rect, LIGHT_GRAY, BLACK, 1)
    v_text = font.render("v", True, BLACK)
    screen.blit(v_text, (250, 308))

    choose_button_text = font.render(calendar_button_chosen, True, BLACK)
    screen.blit(choose_button_text, (60, 308)) 

    if dropdown_colors_open:
        for index, (button_visible_name, color_value) in enumerate(dropdown_colors_list):
            option_rect = pygame.Rect(dropdown_colors_rect.x, (dropdown_colors_rect.y + (index + 1) * 30)+10, 220, 30)
            pygame.draw.rect(screen, color_value, option_rect)
            option_text = font.render(button_visible_name, True, BLACK)
            screen.blit(option_text, (option_rect.x + 10, option_rect.y + 5))

    if dropdown_colors_hub_open:
        for index, (button_visible_name, color_value) in enumerate(dropdown_hub_colors_list):
            option_rect = pygame.Rect(dropdown_colors_hub_rect.x, (dropdown_colors_hub_rect.y + (index + 1) * 30)+10, 220, 30)
            pygame.draw.rect(screen, color_value, option_rect)
            option_text = font.render(button_visible_name, True, BLACK)
            screen.blit(option_text, (option_rect.x + 10, option_rect.y + 5))

    if dropdown_colors_calendar_open:
        for index, (button_visible_name, color_value) in enumerate(dropdown_calendar_colors_list):
            option_rect = pygame.Rect(dropdown_colors_calendar_rect.x, (dropdown_colors_calendar_rect.y + (index + 1) * 20)+20, 220, 20)
            pygame.draw.rect(screen, color_value, option_rect)
            option_text = small_font.render(button_visible_name, True, BLACK)
            screen.blit(option_text, (option_rect.x + 10, option_rect.y))
        
    screen.blit(color_wheel, (300, 100))

    Theme_text = font.render("Themes:", True, BLACK)
    screen.blit(Theme_text, (550,70))

    draw_rounded_button(screen, aquatic_theme, (0,105,148), BLACK, 1)
    draw_rounded_button(screen, foresty_theme, (85,107,47), BLACK, 1)
    draw_rounded_button(screen, girly_pop_theme, (255,182,193), BLACK, 1)
    draw_rounded_button(screen, vampire_goth_theme, (120,0,0), BLACK, 1)
    draw_rounded_button(screen, sunset_glow_theme, (255,140,0), BLACK, 1)

    if hub_toggle.collidepoint(mouse_pos):
        hub_buttons_showing = True
        draw_hub_buttons()
    if hub_buttons_showing:
        draw_hub_buttons()
    if not hub_toggle.collidepoint(mouse_pos) and not hub_cover.collidepoint(mouse_pos):
        hub_buttons_showing = False

def remove_task(task_list, buttons, event):
    global scroll_offset, scroll_last_update_time
    current_time = pygame.time.get_ticks() / 1000  # Current time in seconds
    task_removed = False

    if event.type == pygame.MOUSEBUTTONDOWN:
        for button, index in buttons:
            if button.collidepoint(event.pos):
                task_list.pop(index)  # Remove the task from the list
                task_removed = True  # Flag that a task was removed
                # Adjust scroll_offset if needed
                if scroll_offset > 0 and len(task_list) <= scroll_offset + 8:
                    scroll_offset -= 1
                break  # Exit loop after removing the task

        if task_removed:
            # Rebuild the buttons list after a task is removed
            buttons.clear()
            visible_tasks = task_list[scroll_offset:scroll_offset + 8]
            for i, _ in enumerate(visible_tasks):
                # Recreate the button positions for each task
                button = pygame.Rect(100, 100 + i * 60, 600, 50)
                buttons.append((button, scroll_offset + i))

    # Handle scrolling logic
    if scroll_bar_up_button.collidepoint(pygame.mouse.get_pos()) and pygame.mouse.get_pressed()[0]:
        # Scroll up if enough time has passed since the last scroll
        if current_time - scroll_last_update_time >= scroll_update_interval and scroll_offset > 0:
            scroll_offset -= 1
            scroll_last_update_time = current_time  # Update the last update time
    elif scroll_bar_down_button.collidepoint(pygame.mouse.get_pos()) and pygame.mouse.get_pressed()[0]:
        # Scroll down if enough time has passed since the last scroll
        if current_time - scroll_last_update_time >= scroll_update_interval and scroll_offset < len(task_list) - 8:
            scroll_offset += 1
            scroll_last_update_time = current_time  # Update the last update time

def remove_completed_tasks(tasks_to_remove):
    global spoons
    for index in sorted(tasks_to_remove, reverse=True):
        spoons_needed = tasks[index][1]
        tasks.pop(index)

def complete_task(task_list, buttons, event):
    global spoons, scroll_offset, scroll_last_update_time
    current_time = pygame.time.get_ticks() / 1000  # Current time in seconds
    task_completed = False

    if event.type == pygame.MOUSEBUTTONDOWN:
        # Handle clicking on tasks to mark as complete
        for button, index in buttons:
            if button.collidepoint(event.pos) and task_list[index][2] == "❌":
                if spoons >= task_list[index][1]:
                    task_data = list(task_list[index])  # Convert tuple to list
                    task_data[2] = '✅'  # Mark task as complete
                    task_list[index] = tuple(task_data)  # Update back as tuple
                    spoons -= task_list[index][1]
                    task_completed = True
                    break
                else:
                    print("Not enough spoons to complete this task.")

    # Handle scrolling logic
    if scroll_bar_up_button.collidepoint(pygame.mouse.get_pos()) and pygame.mouse.get_pressed()[0]:
        # Scroll up if enough time has passed since the last scroll
        if current_time - scroll_last_update_time >= scroll_update_interval and scroll_offset > 0:
            scroll_offset -= 1
            scroll_last_update_time = current_time  # Update the last update time
    elif scroll_bar_down_button.collidepoint(pygame.mouse.get_pos()) and pygame.mouse.get_pressed()[0]:
        # Scroll down if enough time has passed since the last scroll
        if current_time - scroll_last_update_time >= scroll_update_interval and scroll_offset < len(task_list) - 8:
            scroll_offset += 1
            scroll_last_update_time = current_time  # Update the last update time

    return task_completed

def hub_buttons(event):
    global scroll_offset
    if not hub_buttons_showing:
        return None
    if event.type == pygame.MOUSEBUTTONDOWN:
        if hub_add_spoons.collidepoint(event.pos):
            return "input_spoons"
        elif hub_add_task.collidepoint(event.pos):
            return "input_tasks"
        elif hub_complete_task.collidepoint(event.pos):
            scroll_offset = 0
            return "complete_tasks"
        elif hub_remove_task.collidepoint(event.pos):
            scroll_offset = 0
            return "remove_tasks"
        elif hub_daily_schedule.collidepoint(event.pos):
            return "daily_schedule"
        elif hub_calendar.collidepoint(event.pos):
            return "calendar"
        elif hub_settings.collidepoint(event.pos):
            return "settings"
    return None 

def get_color_at_pos(pos):
    global r
    global g
    global b
    if color_wheel_rect.collidepoint(pos):
        local_pos = (pos[0] - color_wheel_rect.left, pos[1] - color_wheel_rect.top)
        color = color_wheel.get_at(local_pos)
        if color[3] > 0:
            r, g, b = color[:3]
            return r, g, b
    return None

def task_to_serializable(task):
    if len(task) == 7:  # Task has start_time and end_time
        task_name, spoons_needed, done, days_till_due_date, due_date, start_time, end_time = task
        return {
            "task_name": task_name,
            "spoons_needed": spoons_needed,
            "done": done,
            "days_till_due_date": days_till_due_date,
            "due_date": due_date.isoformat(),
            "start_time": start_time,
            "end_time": end_time
        }
    elif len(task) == 5:  # Task without start_time and end_time
        task_name, spoons_needed, done, days_till_due_date, due_date = task
        return {
            "task_name": task_name,
            "spoons_needed": spoons_needed,
            "done": done,
            "days_till_due_date": days_till_due_date,
            "due_date": due_date.isoformat()
        }

def save_data():
    data = {
        "spoons": spoons,
        "homework_tasks_list": [task_to_serializable(task) for task in homework_tasks_list],
        "chores_tasks_list": [task_to_serializable(task) for task in chores_tasks_list],
        "work_tasks_list": [task_to_serializable(task) for task in work_tasks_list],
        "misc_tasks_list": [task_to_serializable(task) for task in misc_tasks_list],
        "daily_spoons": daily_spoons,  # Save daily spoon values
        "colors": {
            "background_color": background_color,
            "done_button_color": done_button_color,
            "add_tasks_choose_folder_color": add_tasks_choose_folder_color,
            "add_tasks_chosen_folder_color": add_tasks_chosen_folder_color,
            "complete_tasks_hub_folder_color": complete_tasks_hub_folder_color,
            "complete_tasks_task_color": complete_tasks_task_color,
            "remove_tasks_hub_folder_color": remove_tasks_hub_folder_color,
            "remove_tasks_task_color": remove_tasks_task_color,
            "add_spoons_color": add_spoons_color,
            "add_tasks_color": add_tasks_color,
            "complete_tasks_color": complete_tasks_color,
            "remove_tasks_color": remove_tasks_color,
            "daily_schedule_color": daily_schedule_color,
            "calendar_color": calendar_color,
            "settings_color": settings_color,
            "calendar_current_day_color": calendar_current_day_color,
            "calendar_current_day_header_color": calendar_current_day_header_color,
            "calendar_previous_day_color": calendar_previous_day_color,
            "calendar_previous_day_header_color": calendar_previous_day_header_color,
            "calendar_next_day_color": calendar_next_day_color,
            "calendar_next_day_header_color": calendar_next_day_header_color,
            "calendar_month_color": calendar_month_color,
            "homework_fol_color": homework_fol_color,
            "chores_fol_color": chores_fol_color,
            "work_fol_color": work_fol_color,
            "misc_fol_color": misc_fol_color
        }
    }
    try:
        with open("data.json", "w") as f:
            json.dump(data, f)
    except Exception as e:
        print(f"Error saving data: {e}")

def task_from_serializable(task):
    # Default values for start_time and end_time
    default_start_time = [0, 0, 0, 0]
    default_end_time = [0, 0, 0, 0]

    # Extract fields with defaults for optional fields
    task_name = task.get("task_name", "")
    spoons_needed = task.get("spoons_needed", 0)
    done = task.get("done", "❌")
    days_till_due_date = task.get("days_till_due_date", 0)
    due_date_str = task.get("due_date", "1970-01-01T00:00:00")
    due_date = datetime.strptime(due_date_str, '%Y-%m-%dT%H:%M:%S')
    start_time = task.get("start_time", default_start_time)
    end_time = task.get("end_time", default_end_time)

    # Return the task as a list with all fields
    return [task_name, spoons_needed, done, days_till_due_date, due_date, start_time, end_time]

def load_data():
    global spoons, homework_tasks_list, chores_tasks_list, work_tasks_list, misc_tasks_list
    global background_color, done_button_color, add_tasks_choose_folder_color, add_tasks_chosen_folder_color
    global complete_tasks_hub_folder_color, complete_tasks_task_color, remove_tasks_hub_folder_color
    global remove_tasks_task_color, add_spoons_color, add_tasks_color, complete_tasks_color, remove_tasks_color
    global daily_schedule_color, calendar_color, settings_color, calendar_current_day_color
    global calendar_current_day_header_color, calendar_previous_day_color, calendar_previous_day_header_color
    global calendar_next_day_color, calendar_next_day_header_color, calendar_month_color
    global homework_fol_color, chores_fol_color, work_fol_color, misc_fol_color, daily_spoons

    try:
        with open("data.json", "r") as f:
            data = json.load(f)
            print("Loaded data:", data)  # Print all data loaded for verification

            # Task Lists
            spoons = data.get("spoons", 0)
            homework_tasks_list = [task_from_serializable(task) for task in data.get("homework_tasks_list", [])]
            chores_tasks_list = [task_from_serializable(task) for task in data.get("chores_tasks_list", [])]
            work_tasks_list = [task_from_serializable(task) for task in data.get("work_tasks_list", [])]
            misc_tasks_list = [task_from_serializable(task) for task in data.get("misc_tasks_list", [])]
            print("Tasks loaded successfully")

            # Colors
            colors = data.get("colors", {})
            background_color = tuple(colors.get("background_color", (255, 255, 255)))  # Default to white
            done_button_color = tuple(colors.get("done_button_color", (0, 0, 0)))
            add_tasks_choose_folder_color = tuple(colors.get("add_tasks_choose_folder_color", (200, 200, 200)))
            add_tasks_chosen_folder_color = tuple(colors.get("add_tasks_chosen_folder_color", (200, 200, 200)))
            complete_tasks_hub_folder_color = tuple(colors.get("complete_tasks_hub_folder_color", (200, 200, 200)))
            complete_tasks_task_color = tuple(colors.get("complete_tasks_task_color", (200, 200, 200)))
            remove_tasks_hub_folder_color = tuple(colors.get("remove_tasks_hub_folder_color", (200, 200, 200)))
            remove_tasks_task_color = tuple(colors.get("remove_tasks_task_color", (200, 200, 200)))
            add_spoons_color = tuple(colors.get("add_spoons_color", (200, 200, 200)))
            add_tasks_color = tuple(colors.get("add_tasks_color", (200, 200, 200)))
            complete_tasks_color = tuple(colors.get("complete_tasks_color", (200, 200, 200)))
            remove_tasks_color = tuple(colors.get("remove_tasks_color", (200, 200, 200)))
            daily_schedule_color = tuple(colors.get("daily_schedule_color", (200, 200, 200)))
            calendar_color = tuple(colors.get("calendar_color", (200, 200, 200)))
            settings_color = tuple(colors.get("settings_color", (200, 200, 200)))
            calendar_current_day_color = tuple(colors.get("calendar_current_day_color", (200, 200, 200)))
            calendar_current_day_header_color = tuple(colors.get("calendar_current_day_header_color", (200, 200, 200)))
            calendar_previous_day_color = tuple(colors.get("calendar_previous_day_color", (200, 200, 200)))
            calendar_previous_day_header_color = tuple(colors.get("calendar_previous_day_header_color", (200, 200, 200)))
            calendar_next_day_color = tuple(colors.get("calendar_next_day_color", (200, 200, 200)))
            calendar_next_day_header_color = tuple(colors.get("calendar_next_day_header_color", (200, 200, 200)))
            calendar_month_color = tuple(colors.get("calendar_month_color", (200, 200, 200)))
            homework_fol_color = tuple(colors.get("homework_fol_color", (200, 200, 200)))
            chores_fol_color = tuple(colors.get("chores_fol_color", (200, 200, 200)))
            work_fol_color = tuple(colors.get("work_fol_color", (200, 200, 200)))
            misc_fol_color = tuple(colors.get("misc_fol_color", (200, 200, 200)))
            
            # Load daily spoons data
            daily_spoons = data.get("daily_spoons", {"Mon": 0, "Tue": 0, "Wed": 0, "Thu": 0, "Fri": 0, "Sat": 0, "Sun": 0})

    except Exception as e:
        print(f"Error loading data: {e}")

#initiating all colors
background_color = CAMEL
done_button_color = LIME_GREEN
add_tasks_choose_folder_color = BLUE
add_tasks_chosen_folder_color = GOLD
complete_tasks_hub_folder_color = BLUE
complete_tasks_task_color = LIME_GREEN
remove_tasks_hub_folder_color = BLUE
remove_tasks_task_color = LIME_GREEN

add_spoons_color = GOLD
add_tasks_color = LIME_GREEN
complete_tasks_color = GREEN
remove_tasks_color = RED
daily_schedule_color = LIGHT_BLUE
calendar_color = BLUE
settings_color = DARK_GRAY

calendar_current_day_color = CAMEL
calendar_current_day_header_color = GOLD
calendar_previous_day_color = LIGHT_BLUE
calendar_previous_day_header_color = BLUE
calendar_next_day_color = LIGHT_BLUE
calendar_next_day_header_color = BLUE
calendar_month_color = CAMEL
homework_fol_color = BLUE
chores_fol_color = GREEN
work_fol_color = RED
misc_fol_color = GOLD

#initiating variables
short_rest_amount = 2
half_rest_amount = 5
full_rest_amount = 10
tool_tips = True
icon_image = spoon_image
spoon_name = "Spoons"
page = "input_spoons"
folder = "misc"
running = True
time_toggle_on = False
start_time = [0, 0, 0, 0]  # Representing "00:00"
end_time = [0, 0, 0, 0]    # Representing "00:00"
scroll_offset = 0
scroll_last_update_time = 0
scroll_update_interval = 0.1
day_offset = 0
# Define a dictionary for daily spoon values if it tracks spoons per day.
daily_spoons = {
    "Mon": 0,
    "Tue": 0,
    "Wed": 0,
    "Thu": 0,
    "Fri": 0,
    "Sat": 0,
    "Sun": 0}

load_data()

# ----------------------------------------------------------------------------------------------------
# Main loop
# ----------------------------------------------------------------------------------------------------

while running:
    max_days = calendar.monthrange(datetime.now().year, task_month)[1]  # Get days in the current month
    mouse_pos = pygame.mouse.get_pos()
    current_month = datetime.now().month
    current_day = datetime.now().day
# Check if the day or month has changed to update task days and reset spoons
    if int(current_day) > int(previous_day) or int(current_month) > int(previous_month):
        # Get the current day of the week (0 = Monday, 6 = Sunday)
        # Get the current weekday as a three-letter abbreviation
        current_weekday = datetime.now().strftime("%a")  # This will give "Mon", "Tue", etc.

        # Set spoons to the corresponding daily value
        spoons = daily_spoons.get(current_weekday, spoons)


        # Update tasks in each list to decrement days left
        if homework_tasks_list:
            for task in homework_tasks_list:
                if task[3] > 0:  # Ensure days don't go below zero
                    task[3] -= 1
        if chores_tasks_list:
            for task in chores_tasks_list:
                if task[3] > 0:
                    task[3] -= 1
        if work_tasks_list:
            for task in work_tasks_list:
                if task[3] > 0:
                    task[3] -= 1
        if misc_tasks_list:
            for task in misc_tasks_list:
                if task[3] > 0:
                    task[3] -= 1

        # Update the previous day and month to the current values
        previous_day = current_day
        previous_month = current_month
        print(f"Date changed: {current_month}/{current_day}. Days left updated and spoons reset to {spoons}.")

    screen.fill(background_color)
    tasks_to_remove = []

    if page == "input_spoons":
        draw_input_spoons()
    elif page == "input_tasks":
        draw_input_tasks()
    elif page == "complete_tasks":
        draw_complete_tasks_hub()
    elif page == "complete_homework_tasks":
        draw_complete_tasks("Homework", homework_tasks_list, task_buttons_homework)
    elif page == "complete_chores_tasks":
        draw_complete_tasks("Chores", chores_tasks_list, task_buttons_chores)
    elif page == "complete_work_tasks":
        draw_complete_tasks("Work", work_tasks_list, task_buttons_work)
    elif page == "complete_misc_tasks":
        draw_complete_tasks("Misc", misc_tasks_list, task_buttons_misc)
    elif page == "remove_tasks":
        draw_remove_tasks_hub()
    elif page == "remove_homework_tasks":
        draw_remove_tasks("Homework", homework_tasks_list, task_buttons_homework)
    elif page == "remove_chores_tasks":
        draw_remove_tasks("Chores", chores_tasks_list, task_buttons_chores)
    elif page == "remove_work_tasks":
        draw_remove_tasks("Work", work_tasks_list, task_buttons_work)
    elif page == "remove_misc_tasks":
        draw_remove_tasks("Misc", misc_tasks_list, task_buttons_misc)
    elif page == "daily_schedule":
        draw_daily_schedule()
    elif page == "calendar":
        draw_calendar()
    elif page == "settings":
        draw_settings()

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            save_data()
            running = False
        handle_scroll(event)
        if event.type in (pygame.MOUSEBUTTONDOWN, pygame.MOUSEMOTION):
            if hub_buttons_showing and hub_cover.collidepoint(event.pos):
                new_page = hub_buttons(event)
                if new_page:
                    page = new_page
                continue
        new_page = hub_buttons(event)
        if new_page:
            page = new_page

        if page == "input_spoons":
            # Draw the interface and get the dictionary of day input boxes
            daily_spoon_inputs = draw_input_spoons()

            if event.type == pygame.MOUSEBUTTONDOWN:
                # Check for general input box and rest buttons
                if spoon_amount_input_box.collidepoint(event.pos):
                    input_active = "spoons"  # Activate general spoons input
                elif spoon_done_button.collidepoint(event.pos):
                    page = "input_tasks"
                    input_active = False  # Deactivate after done
                elif short_rest_button.collidepoint(event.pos):
                    spoons += short_rest_amount
                elif half_rest_button.collidepoint(event.pos):
                    spoons += half_rest_amount
                elif full_rest_button.collidepoint(event.pos):
                    spoons += full_rest_amount
                else:
                    # Check each day’s input box
                    for day, box in daily_spoon_inputs.items():
                        if box.collidepoint(event.pos):
                            input_active = day  # Activate input for the specific day
                            break
                    else:
                        input_active = False  # Deactivate if clicked outside all boxes

            # Handle text input for spoons or daily spoon counts
            if event.type == pygame.KEYDOWN and input_active:
                if event.key == pygame.K_RETURN:
                    # Deactivate on Enter
                    page = "input_tasks"
                    input_active = False
                elif event.key == pygame.K_BACKSPACE:
                    # Backspace handling
                    if input_active == "spoons":
                        spoons = spoons // 10
                    else:
                        daily_spoons[input_active] = daily_spoons.get(input_active, 0) // 10
                else:
                    try:
                        # Update either general spoons or specific day's spoon count
                        if input_active == "spoons":
                            spoons = spoons * 10 + int(event.unicode)
                        else:
                            # Update the daily spoon count for the specific day
                            daily_spoons[input_active] = daily_spoons.get(input_active, 0) * 10 + int(event.unicode)
                    except ValueError:
                        pass
        elif page == "input_tasks":
            if event.type == pygame.MOUSEBUTTONDOWN:
                # Toggle time entry
                if time_toggle_button.collidepoint(event.pos):
                    time_toggle_on = not time_toggle_on

                # Task input boxes
                if task_input_box.collidepoint(event.pos):
                    input_active = "task"
                elif spoon_input_box.collidepoint(event.pos):
                    input_active = "spoons"

                # Month and day button handling
                if time_toggle_on:
                    if month_up_button_shifted.collidepoint(event.pos):
                        task_month = task_month + 1 if task_month < 12 else 1
                    elif month_down_button_shifted.collidepoint(event.pos):
                        task_month = task_month - 1 if task_month > 1 else 12
                    elif day_up_button_shifted.collidepoint(event.pos):
                        task_day = int(task_day) + 1 if int(task_day) < max_days else 1
                    elif day_down_button_shifted.collidepoint(event.pos):
                        task_day = int(task_day) - 1 if int(task_day) > 1 else max_days
                else:
                    if month_up_button_normal.collidepoint(event.pos):
                        task_month = task_month + 1 if task_month < 12 else 1
                    elif month_down_button_normal.collidepoint(event.pos):
                        task_month = task_month - 1 if task_month > 1 else 12
                    elif day_up_button_normal.collidepoint(event.pos):
                        task_day = int(task_day) + 1 if int(task_day) < max_days else 1
                    elif day_down_button_normal.collidepoint(event.pos):
                        task_day = int(task_day) - 1 if int(task_day) > 1 else max_days

                # Start and end time input boxes
                if start_time_input_box.collidepoint(event.pos):
                    input_active = "start_time"
                elif end_time_input_box.collidepoint(event.pos):
                    input_active = "end_time"

                # Done button
                elif done_button.collidepoint(event.pos):
                    if current_task and current_spoons:
                        task_date = datetime(current_time.year, int(task_month), int(task_day))
                        days_till_due_date = (task_date - current_time).days

                        # Append to the appropriate task list based on folder
                        task_entry = [current_task, current_spoons, "❌", days_till_due_date+1, task_date]
                        if time_toggle_on:  # Only add times if the toggle is on
                            task_entry.extend([start_time, end_time])
                        else:
                            task_entry.extend([[0,0,0,0],[0,0,0,0]])
                        
                        if folder == "homework":
                            homework_tasks_list.append(task_entry)
                        elif folder == "chores":
                            chores_tasks_list.append(task_entry)
                        elif folder == "work":
                            work_tasks_list.append(task_entry)
                        elif folder == "misc":
                            misc_tasks_list.append(task_entry)

                        # Reset inputs
                        current_task = ""
                        current_spoons = 0
                        input_active = False
                    else:
                        page = "complete_tasks"

                # Folder selection
                if homework_tasks.collidepoint(event.pos):
                    folder = "homework"
                elif chores_tasks.collidepoint(event.pos):
                    folder = "chores"
                elif work_tasks.collidepoint(event.pos):
                    folder = "work"
                elif misc_tasks.collidepoint(event.pos):
                    folder = "misc"

            # Handle key inputs for task name, spoons, day, and time
            if event.type == pygame.KEYDOWN:
                if input_active == "task":
                    if event.key == pygame.K_RETURN:
                        input_active = "spoons"
                    elif event.key == pygame.K_BACKSPACE:
                        current_task = current_task[:-1]
                    else:
                        current_task += event.unicode

                elif input_active == "spoons":
                    if event.key == pygame.K_RETURN:
                        if current_task and current_spoons:
                            tasks.append((current_task, current_spoons))
                            current_task = ""
                            current_spoons = 0
                        else:
                            page = "complete_tasks"
                        input_active = False
                    elif event.key == pygame.K_BACKSPACE:
                        current_spoons = current_spoons // 10
                    else:
                        try:
                            current_spoons = current_spoons * 10 + int(event.unicode)
                        except ValueError:
                            pass

                elif input_active in ["start_time", "end_time"]:
                    # Choose the correct time list to modify
                    time_component = start_time if input_active == "start_time" else end_time

                    # Shift time digits to the left with new input
                    if event.key == pygame.K_BACKSPACE:
                        time_component = [0] + time_component[:3]  # Shift right with a leading zero
                    elif event.unicode.isdigit():
                        # Shift left and add the new digit at the end
                        time_component = time_component[1:] + [int(event.unicode)]

                    # Update the correct variable
                    if input_active == "start_time":
                        start_time = time_component
                    elif input_active == "end_time":
                        end_time = time_component
                     
        elif page == "complete_tasks":
            if event.type == pygame.MOUSEBUTTONDOWN:
                if complete_homework_tasks.collidepoint(event.pos):
                    page = "complete_homework_tasks"
                elif complete_chores_tasks.collidepoint(event.pos):
                    page = "complete_chores_tasks"
                elif complete_work_tasks.collidepoint(event.pos):
                    page = "complete_work_tasks"
                elif complete_misc_tasks.collidepoint(event.pos):
                    page = "complete_misc_tasks"
        elif page == "complete_homework_tasks":
            complete_task(homework_tasks_list, task_buttons_homework, event)
        elif page == "complete_chores_tasks":
            complete_task(chores_tasks_list, task_buttons_chores, event)
        elif page == "complete_work_tasks":
            complete_task(work_tasks_list, task_buttons_work, event)
        elif page == "complete_misc_tasks":
            complete_task(misc_tasks_list, task_buttons_misc, event)

        elif page == "remove_tasks":
            if event.type == pygame.MOUSEBUTTONDOWN:
                if complete_homework_tasks.collidepoint(event.pos):
                    page = "remove_homework_tasks"
                elif complete_chores_tasks.collidepoint(event.pos):
                    page = "remove_chores_tasks"
                elif complete_work_tasks.collidepoint(event.pos):
                    page = "remove_work_tasks"
                elif complete_misc_tasks.collidepoint(event.pos):
                    page = "remove_misc_tasks"
                elif remove_all_tasks_button.collidepoint(event.pos):
                    homework_tasks_list = []
                    chores_tasks_list = []
                    work_tasks_list = []
                    misc_tasks_list = []
        elif page == "remove_homework_tasks":
            remove_task(homework_tasks_list, task_buttons_homework, event)
        elif page == "remove_chores_tasks":
            remove_task(chores_tasks_list, task_buttons_chores, event)
        elif page == "remove_work_tasks":
            remove_task(work_tasks_list, task_buttons_work, event)
        elif page == "remove_misc_tasks":
            remove_task(misc_tasks_list, task_buttons_misc, event)

        elif page == "calendar": 
            if event.type == pygame.MOUSEBUTTONDOWN:
                if previous_month_button.collidepoint(event.pos):
                    displayed_month -= 1
                    if displayed_month < 1:
                        displayed_month = 12
                        displayed_year -= 1
                elif next_month_button.collidepoint(event.pos):
                    displayed_month += 1
                    if displayed_month > 12:
                        displayed_month = 1
                        displayed_year += 1
        elif page == "daily_schedule":
            if event.type == pygame.MOUSEBUTTONDOWN:
                if last_day_button.collidepoint(event.pos):
                    day_offset -= 1  # Move back one day
                elif next_day_button.collidepoint(event.pos):
                    day_offset += 1  # Move forward one day
                    # Step 1: Get the available time blocks by date and the initial task schedule
                    available_blocks_by_date, task_schedule = get_available_time_blocks(class_schedule)

                    # Step 2: Sort unscheduled tasks by priority and due date
                    sorted_tasks = sort_tasks_by_priority_and_due_date()

                    # Step 3: Call allocate_tasks_to_time_blocks with the necessary inputs
                    # Note: We're not passing task_schedule directly to `allocate_tasks_to_time_blocks`, so it will
                    #       dynamically add scheduled tasks into the returned final_schedule.
                    final_schedule = allocate_tasks_to_time_blocks(available_blocks_by_date, sorted_tasks)

                    # Step 4: Print the final schedule to verify the results
                    for date, tasks in final_schedule.items():
                        print(f"Date: {date}")
                        for task in tasks:
                            # Check if task has the expected keys
                            if "name" in task and "start_time" in task and "end_time" in task:
                                print(f"  Task: {task['name']}, Start: {task['start_time']}, End: {task['end_time']}")
                            else:
                                # Print the task directly if structure is unexpected for further inspection
                                print("  Task (unexpected structure):", task)


        elif page == "settings":
            if event.type == pygame.MOUSEBUTTONDOWN:
                if tool_tip_toggle.collidepoint(event.pos):
                    tool_tips = not tool_tips
                if spoon_name_input_box.collidepoint(event.pos):
                    input_active = "spoon_name"
                else:
                    input_active = False
                if spoon_image_outline.collidepoint(event.pos):
                    icon_image = spoon_image
                if battery_image_outline.collidepoint(event.pos):
                    icon_image = battery_image
                if star_image_outline.collidepoint(event.pos):
                    icon_image = star_image
                if potion_image_outline.collidepoint(event.pos):
                    icon_image = potion_image
                if aquatic_theme.collidepoint(event.pos):
                    background_color = (0, 105, 148)  # Deep Aquatic Blue
                    done_button_color = (72, 209, 204)  # Medium Turquoise
                    add_tasks_choose_folder_color = (32, 178, 170)  # Light Sea Green
                    add_tasks_chosen_folder_color = (0, 191, 255)  # Deep Sky Blue
                    complete_tasks_hub_folder_color = (0, 139, 139)  # Dark Cyan
                    complete_tasks_task_color = (127, 255, 212)  # Aquamarine
                    remove_tasks_hub_folder_color = (0, 149, 182)  # Blue Lagoon
                    remove_tasks_task_color = (64, 224, 208)  # Turquoise
                    add_spoons_color = (0, 191, 255)  # Deep Sky Blue
                    add_tasks_color = (0, 139, 139)  # Dark Cyan
                    complete_tasks_color = (127, 255, 212)  # Aquamarine
                    remove_tasks_color = (64, 224, 208)  # Turquoise
                    daily_schedule_color = (32, 178, 170)  # Light Sea Green
                    calendar_color = (0, 149, 182)  # Blue Lagoon
                    settings_color = (0, 105, 148)  # Deep Aquatic Blue
                    calendar_current_day_color = (0, 105, 148)  # Deep Aquatic Blue
                    calendar_current_day_header_color = (72, 209, 204)  # Medium Turquoise
                    calendar_previous_day_color = (32, 178, 170)  # Light Sea Green
                    calendar_previous_day_header_color = (0, 191, 255)  # Deep Sky Blue
                    calendar_next_day_color = (127, 255, 212)  # Aquamarine
                    calendar_next_day_header_color = (0, 139, 139)  # Dark Cyan
                    calendar_month_color = (0, 149, 182)  # Blue Lagoon
                    homework_fol_color = (0, 105, 148)  # Deep Aquatic Blue
                    chores_fol_color = (72, 209, 204)  # Medium Turquoise
                    work_fol_color = (0, 191, 255)  # Deep Sky Blue
                    misc_fol_color = (64, 224, 208)  # Turquoise
                    dropdown_colors_list = [
                        ["background", (0, 105, 148)],  # Deep Aquatic Blue
                        ["done button", (72, 209, 204)],  # Medium Turquoise
                        ["folder choices", (32, 178, 170)],  # Light Sea Green
                        ["chosen folder", (0, 191, 255)],  # Deep Sky Blue
                        ["choose folder C", (0, 139, 139)],  # Dark Cyan
                        ["complete task", (127, 255, 212)],  # Aquamarine
                        ["choose folder R", (0, 149, 182)],  # Blue Lagoon
                        ["remove task", (64, 224, 208)]  # Turquoise
                    ]
                    dropdown_hub_colors_list = [
                        ["add spoons", (0, 191, 255)],  # Deep Sky Blue
                        ["add tasks", (0, 139, 139)],  # Dark Cyan
                        ["complete tasks", (127, 255, 212)],  # Aquamarine
                        ["remove tasks", (64, 224, 208)],  # Turquoise
                        ["daily schedule", (32, 178, 170)],  # Light Sea Green
                        ["calendar", (0, 149, 182)],  # Blue Lagoon
                        ["settings", (0, 105, 148)]  # Deep Aquatic Blue
                    ]
                    dropdown_calendar_colors_list = [
                        ["current day", (0, 105, 148)],
                        ["cur day header", (72, 209, 204)],
                        ["previous day", (32, 178, 170)],
                        ["pre day header", (0, 191, 255)],
                        ["next day", (127, 255, 212)],
                        ["next day header", (0, 139, 139)],
                        ["month pre/next", (0, 149, 182)],
                        ["homework fol", (0, 105, 148)],
                        ["chores fol", (72, 209, 204)],
                        ["work fol", (0, 191, 255)],
                        ["misc fol", (64, 224, 208)]
                    ]
                elif foresty_theme.collidepoint(event.pos):
                    background_color = (85, 107, 47)  # Dark Olive Green
                    done_button_color = (107, 142, 35)  # Olive Drab
                    add_tasks_choose_folder_color = (143, 188, 143)  # Dark Sea Green
                    add_tasks_chosen_folder_color = (192, 192, 192)  # Silver Sage
                    complete_tasks_hub_folder_color = (60, 179, 113)  # Medium Sea Green
                    complete_tasks_task_color = (152, 251, 152)  # Pale Green
                    remove_tasks_hub_folder_color = (34, 139, 34)  # Forest Green
                    remove_tasks_task_color = (124, 252, 0)  # Lawn Green
                    add_spoons_color = (107, 142, 35)  # Olive Drab
                    add_tasks_color = (143, 188, 143)  # Dark Sea Green
                    complete_tasks_color = (152, 251, 152)  # Pale Green
                    remove_tasks_color = (34, 139, 34)  # Forest Green
                    daily_schedule_color = (60, 179, 113)  # Medium Sea Green
                    calendar_color = (124, 252, 0)  # Lawn Green
                    settings_color = (85, 107, 47)  # Dark Olive Green
                    calendar_current_day_color = (85, 107, 47)  # Dark Olive Green
                    calendar_current_day_header_color = (107, 142, 35)  # Olive Drab
                    calendar_previous_day_color = (143, 188, 143)  # Dark Sea Green
                    calendar_previous_day_header_color = (60, 179, 113)  # Medium Sea Green
                    calendar_next_day_color = (152, 251, 152)  # Pale Green
                    calendar_next_day_header_color = (34, 139, 34)  # Forest Green
                    calendar_month_color = (85, 107, 47)  # Dark Olive Green
                    homework_fol_color = (107, 142, 35)  # Olive Drab
                    chores_fol_color = (143, 188, 143)  # Dark Sea Green
                    work_fol_color = (34, 139, 34)  # Forest Green
                    misc_fol_color = (60, 179, 113)  # Medium Sea Green
                    dropdown_colors_list = [
                        ["background", (85, 107, 47)],  # Dark Olive Green
                        ["done button", (107, 142, 35)],  # Olive Drab
                        ["folder choices", (143, 188, 143)],  # Dark Sea Green
                        ["chosen folder", (192, 192, 192)],  # Silver Sage
                        ["choose folder C", (60, 179, 113)],  # Medium Sea Green
                        ["complete task", (152, 251, 152)],  # Pale Green
                        ["choose folder R", (34, 139, 34)],  # Forest Green
                        ["remove task", (124, 252, 0)]  # Lawn Green
                    ]
                    dropdown_hub_colors_list = [
                        ["add spoons", (107, 142, 35)],  # Olive Drab
                        ["add tasks", (143, 188, 143)],  # Dark Sea Green
                        ["complete tasks", (152, 251, 152)],  # Pale Green
                        ["remove tasks", (34, 139, 34)],  # Forest Green
                        ["daily schedule", (60, 179, 113)],  # Medium Sea Green
                        ["calendar", (124, 252, 0)],  # Lawn Green
                        ["settings", (85, 107, 47)]  # Dark Olive Green
                    ]
                    dropdown_calendar_colors_list = [
                        ["current day", (85, 107, 47)],
                        ["cur day header", (107, 142, 35)],
                        ["previous day", (143, 188, 143)],
                        ["pre day header", (60, 179, 113)],
                        ["next day", (152, 251, 152)],
                        ["next day header", (34, 139, 34)],
                        ["month pre/next", (85, 107, 47)],
                        ["homework fol", (107, 142, 35)],
                        ["chores fol", (143, 188, 143)],
                        ["work fol", (34, 139, 34)],
                        ["misc fol", (60, 179, 113)]
                    ]
                elif girly_pop_theme.collidepoint(event.pos):
                    background_color = (255, 182, 193)  # Light Pink
                    done_button_color = (255, 240, 245)  # Lavender Blush
                    add_tasks_choose_folder_color = (219, 112, 147)  # Pale Violet Red
                    add_tasks_chosen_folder_color = (230, 230, 250)  # Lavender
                    complete_tasks_hub_folder_color = (221, 160, 221)  # Plum
                    complete_tasks_task_color = (250, 235, 215)  # Antique White
                    remove_tasks_hub_folder_color = (255, 160, 122)  # Light Salmon
                    remove_tasks_task_color = (255, 228, 225)  # Misty Rose
                    add_spoons_color = (255, 240, 245)  # Lavender Blush
                    add_tasks_color = (219, 112, 147)  # Pale Violet Red
                    complete_tasks_color = (250, 235, 215)  # Antique White
                    remove_tasks_color = (255, 160, 122)  # Light Salmon
                    daily_schedule_color = (230, 230, 250)  # Lavender
                    calendar_color = (221, 160, 221)  # Plum
                    settings_color = (255, 182, 193)  # Light Pink
                    calendar_current_day_color = (255, 182, 193)  # Light Pink
                    calendar_current_day_header_color = (255, 240, 245)  # Lavender Blush
                    calendar_previous_day_color = (219, 112, 147)  # Pale Violet Red
                    calendar_previous_day_header_color = (230, 230, 250)  # Lavender
                    calendar_next_day_color = (221, 160, 221)  # Plum
                    calendar_next_day_header_color = (250, 235, 215)  # Antique White
                    calendar_month_color = (255, 182, 193)  # Light Pink
                    homework_fol_color = (219, 112, 147)  # Pale Violet Red
                    chores_fol_color = (255, 240, 245)  # Lavender Blush
                    work_fol_color = (221, 160, 221)  # Plum
                    misc_fol_color = (255, 228, 225)  # Misty Rose
                    dropdown_colors_list = [
                        ["background", (255, 182, 193)],  # Light Pink
                        ["done button", (255, 240, 245)],  # Lavender Blush
                        ["folder choices", (219, 112, 147)],  # Pale Violet Red
                        ["chosen folder", (230, 230, 250)],  # Lavender
                        ["choose folder C", (221, 160, 221)],  # Plum
                        ["complete task", (250, 235, 215)],  # Antique White
                        ["choose folder R", (255, 160, 122)],  # Light Salmon
                        ["remove task", (255, 228, 225)]  # Misty Rose
                    ]
                    dropdown_hub_colors_list = [
                        ["add spoons", (255, 240, 245)],  # Lavender Blush
                        ["add tasks", (219, 112, 147)],  # Pale Violet Red
                        ["complete tasks", (250, 235, 215)],  # Antique White
                        ["remove tasks", (255, 160, 122)],  # Light Salmon
                        ["daily schedule", (230, 230, 250)],  # Lavender
                        ["calendar", (221, 160, 221)],  # Plum
                        ["settings", (255, 182, 193)]  # Light Pink
                    ]
                    dropdown_calendar_colors_list = [
                        ["current day", (255, 182, 193)],
                        ["cur day header", (255, 240, 245)],
                        ["previous day", (219, 112, 147)],
                        ["pre day header", (230, 230, 250)],
                        ["next day", (221, 160, 221)],
                        ["next day header", (250, 235, 215)],
                        ["month pre/next", (255, 182, 193)],
                        ["homework fol", (219, 112, 147)],
                        ["chores fol", (255, 240, 245)],
                        ["work fol", (221, 160, 221)],
                        ["misc fol", (255, 228, 225)]
                    ]
                elif vampire_goth_theme.collidepoint(event.pos):
                    background_color = (120, 0, 0)  # Crimson Red
                    done_button_color = (75, 0, 130)  # Indigo
                    add_tasks_choose_folder_color = (54, 69, 79)  # Dark Slate Gray
                    add_tasks_chosen_folder_color = (105, 105, 105)  # Dim Gray
                    complete_tasks_hub_folder_color = (128, 0, 0)  # Maroon
                    complete_tasks_task_color = (139, 0, 0)  # Dark Red
                    remove_tasks_hub_folder_color = (72, 61, 139)  # Dark Slate Blue
                    remove_tasks_task_color = (47, 79, 79)  # Dark Slate Gray
                    add_spoons_color = (75, 0, 130)  # Indigo
                    add_tasks_color = (54, 69, 79)  # Dark Slate Gray
                    complete_tasks_color = (139, 0, 0)  # Dark Red
                    remove_tasks_color = (72, 61, 139)  # Dark Slate Blue
                    daily_schedule_color = (105, 105, 105)  # Dim Gray
                    calendar_color = (128, 0, 0)  # Maroon
                    settings_color = (120, 0, 0)  # Crimson Red
                    calendar_current_day_color = (120, 0, 0)  # Crimson Red
                    calendar_current_day_header_color = (75, 0, 130)  # Indigo
                    calendar_previous_day_color = (54, 69, 79)  # Dark Slate Gray
                    calendar_previous_day_header_color = (105, 105, 105)  # Dim Gray
                    calendar_next_day_color = (128, 0, 0)  # Maroon
                    calendar_next_day_header_color = (139, 0, 0)  # Dark Red
                    calendar_month_color = (120, 0, 0)  # Crimson Red
                    homework_fol_color = (75, 0, 130)  # Indigo
                    chores_fol_color = (54, 69, 79)  # Dark Slate Gray
                    work_fol_color = (128, 0, 0)  # Maroon
                    misc_fol_color = (47, 79, 79)  # Dark Slate Gray
                    dropdown_colors_list = [
                        ["background", (120, 0, 0)],  # Crimson Red
                        ["done button", (75, 0, 130)],  # Indigo
                        ["folder choices", (54, 69, 79)],  # Dark Slate Gray
                        ["chosen folder", (105, 105, 105)],  # Dim Gray
                        ["choose folder C", (128, 0, 0)],  # Maroon
                        ["complete task", (139, 0, 0)],  # Dark Red
                        ["choose folder R", (72, 61, 139)],  # Dark Slate Blue
                        ["remove task", (47, 79, 79)]  # Dark Slate Gray
                    ]
                    dropdown_hub_colors_list = [
                        ["add spoons", (75, 0, 130)],  # Indigo
                        ["add tasks", (54, 69, 79)],  # Dark Slate Gray
                        ["complete tasks", (139, 0, 0)],  # Dark Red
                        ["remove tasks", (72, 61, 139)],  # Dark Slate Blue
                        ["daily schedule", (105, 105, 105)],  # Dim Gray
                        ["calendar", (128, 0, 0)],  # Maroon
                        ["settings", (120, 0, 0)]  # Crimson Red
                    ]
                    dropdown_calendar_colors_list = [
                        ["current day", (120, 0, 0)],
                        ["cur day header", (75, 0, 130)],
                        ["previous day", (54, 69, 79)],
                        ["pre day header", (105, 105, 105)],
                        ["next day", (128, 0, 0)],
                        ["next day header", (139, 0, 0)],
                        ["month pre/next", (120, 0, 0)],
                        ["homework fol", (75, 0, 130)],
                        ["chores fol", (54, 69, 79)],
                        ["work fol", (128, 0, 0)],
                        ["misc fol", (47, 79, 79)]
                    ]
                elif sunset_glow_theme.collidepoint(event.pos):
                    background_color = (255, 140, 0)  # Dark Orange
                    done_button_color = (255, 69, 0)  # Red Orange
                    add_tasks_choose_folder_color = (255, 165, 0)  # Orange
                    add_tasks_chosen_folder_color = (255, 99, 71)  # Tomato
                    complete_tasks_hub_folder_color = (255, 127, 80)  # Coral
                    complete_tasks_task_color = (255, 215, 0)  # Gold
                    remove_tasks_hub_folder_color = (255, 182, 193)  # Light Pink
                    remove_tasks_task_color = (255, 160, 122)  # Light Salmon
                    add_spoons_color = (255, 99, 71)  # Tomato
                    add_tasks_color = (255, 165, 0)  # Orange
                    complete_tasks_color = (255, 127, 80)  # Coral
                    remove_tasks_color = (255, 160, 122)  # Light Salmon
                    daily_schedule_color = (255, 215, 0)  # Gold
                    calendar_color = (255, 140, 0)  # Dark Orange
                    settings_color = (255, 69, 0)  # Red Orange
                    calendar_current_day_color = (255, 140, 0)  # Dark Orange
                    calendar_current_day_header_color = (255, 69, 0)  # Red Orange
                    calendar_previous_day_color = (255, 165, 0)  # Orange
                    calendar_previous_day_header_color = (255, 99, 71)  # Tomato
                    calendar_next_day_color = (255, 127, 80)  # Coral
                    calendar_next_day_header_color = (255, 215, 0)  # Gold
                    calendar_month_color = (255, 140, 0)  # Dark Orange
                    homework_fol_color = (255, 69, 0)  # Red Orange
                    chores_fol_color = (255, 165, 0)  # Orange
                    work_fol_color = (255, 127, 80)  # Coral
                    misc_fol_color = (255, 160, 122)  # Light Salmon
                    dropdown_colors_list = [
                        ["background", (255, 140, 0)],  # Dark Orange
                        ["done button", (255, 69, 0)],  # Red Orange
                        ["folder choices", (255, 165, 0)],  # Orange
                        ["chosen folder", (255, 99, 71)],  # Tomato
                        ["choose folder C", (255, 127, 80)],  # Coral
                        ["complete task", (255, 215, 0)],  # Gold
                        ["choose folder R", (255, 182, 193)],  # Light Pink
                        ["remove task", (255, 160, 122)]  # Light Salmon
                    ]
                    dropdown_hub_colors_list = [
                        ["add spoons", (255, 99, 71)],  # Tomato
                        ["add tasks", (255, 165, 0)],  # Orange
                        ["complete tasks", (255, 127, 80)],  # Coral
                        ["remove tasks", (255, 160, 122)],  # Light Salmon
                        ["daily schedule", (255, 215, 0)],  # Gold
                        ["calendar", (255, 140, 0)],  # Dark Orange
                        ["settings", (255, 69, 0)]  # Red Orange
                    ]
                    dropdown_calendar_colors_list = [
                        ["current day", (255, 140, 0)],
                        ["cur day header", (255, 69, 0)],
                        ["previous day", (255, 165, 0)],
                        ["pre day header", (255, 99, 71)],
                        ["next day", (255, 127, 80)],
                        ["next day header", (255, 215, 0)],
                        ["month pre/next", (255, 140, 0)],
                        ["homework fol", (255, 69, 0)],
                        ["chores fol", (255, 165, 0)],
                        ["work fol", (255, 127, 80)],
                        ["misc fol", (255, 160, 122)]
                    ]
  
                if dropdown_colors_rect.collidepoint(event.pos):
                    # Toggle the dropdown
                    dropdown_colors_open = not dropdown_colors_open
                    dropdown_colors_hub_open = False
                    hub_button_chosen = ""
                    dropdown_colors_calendar_open = False
                    calendar_button_chosen = ""
                else:
                    # Handle selection from the dropdown if it's open
                    if dropdown_colors_open:
                        for index, (button_visible_name,color_value) in enumerate(dropdown_colors_list):
                            # Create a rectangle for each dropdown option
                            option_rect = pygame.Rect(dropdown_colors_rect.x, (dropdown_colors_rect.y + (index + 1) * 30)+10, 200, 30)
    
                            # Check if the mouse click is within the current dropdown option
                            if option_rect.collidepoint(event.pos):
                                button_chosen = button_visible_name  # Update the selected variable
                                
                                break  # Exit loop after selecting an option

                if dropdown_colors_hub_rect.collidepoint(event.pos):
                    # Toggle the dropdown
                    dropdown_colors_hub_open = not dropdown_colors_hub_open
                    dropdown_colors_open = False
                    button_chosen = ""
                    dropdown_colors_calendar_open = False
                    calendar_button_chosen = ""
                else:
                    # Handle selection from the dropdown if it's open
                    if dropdown_colors_hub_open:
                        for index, (button_visible_name,color_value) in enumerate(dropdown_hub_colors_list):
                            # Create a rectangle for each dropdown option
                            option_rect = pygame.Rect(dropdown_colors_hub_rect.x, (dropdown_colors_hub_rect.y + (index + 1) * 30)+10, 200, 30)

                            # Check if the mouse click is within the current dropdown option
                            if option_rect.collidepoint(event.pos):
                                hub_button_chosen = button_visible_name  # Update the selected variable

                                break  # Exit loop after selecting an option

                if dropdown_colors_calendar_rect.collidepoint(event.pos):
                    # Toggle the dropdown
                    dropdown_colors_calendar_open = not dropdown_colors_calendar_open
                    dropdown_colors_hub_open = False
                    button_chosen = ""
                    dropdown_colors_open = False
                    hub_button_chosen = ""
                else:
                    # Handle selection from the dropdown if it's open
                    if dropdown_colors_calendar_open:
                        for index, (button_visible_name,color_value) in enumerate(dropdown_calendar_colors_list):
                            # Create a rectangle for each dropdown option
                            option_rect = pygame.Rect(dropdown_colors_calendar_rect.x, (dropdown_colors_calendar_rect.y + (index + 1) * 20)+20, 200, 20)

                            # Check if the mouse click is within the current dropdown option
                            if option_rect.collidepoint(event.pos):
                                calendar_button_chosen = button_visible_name  # Update the selected variable

                                break  # Exit loop after selecting an option
    
                # Handle color wheel click
                selected_color = get_color_at_pos(event.pos)
                if hub_button_chosen == "" and calendar_button_chosen == "":
                    if selected_color:
                        for item in dropdown_colors_list:
                            if item[0] == button_chosen:
                                item[1] = selected_color
                                break
                        if button_chosen == "background":
                            background_color = selected_color
                        elif button_chosen == "done button":
                            done_button_color = selected_color
                        elif button_chosen == "folder choices":
                            add_tasks_choose_folder_color = selected_color
                        elif button_chosen == "chosen folder":
                            add_tasks_chosen_folder_color= selected_color   
                        elif button_chosen == "choose folder C":
                            complete_tasks_hub_folder_color = selected_color
                        elif button_chosen == "complete task":
                            complete_tasks_task_color = selected_color
                        elif button_chosen == "choose folder R":
                            remove_tasks_hub_folder_color = selected_color  
                        elif button_chosen == "remove task":
                            remove_tasks_task_color = selected_color  

                if button_chosen == "" and calendar_button_chosen == "":
                    if selected_color:
                        for item in dropdown_hub_colors_list:
                            if item[0] == hub_button_chosen:
                                item[1] = selected_color
                                break
                        if hub_button_chosen == "add spoons":
                            add_spoons_color = selected_color
                        if hub_button_chosen == "add tasks":
                            add_tasks_color = selected_color
                        if hub_button_chosen == "complete tasks":
                            complete_tasks_color = selected_color
                        if hub_button_chosen == "remove tasks":
                            remove_tasks_color = selected_color
                        if hub_button_chosen == "daily schedule":
                            daily_schedule_color = selected_color
                        if hub_button_chosen == "calendar":
                            calendar_color = selected_color
                        if hub_button_chosen == "settings":
                            settings_color = selected_color
                
                if button_chosen == "" and hub_button_chosen == "":
                    if selected_color:
                        for item in dropdown_calendar_colors_list:
                            if item[0] == calendar_button_chosen:
                                item[1] = selected_color
                                break
                        if calendar_button_chosen == "current day":
                            calendar_current_day_color = selected_color
                        if calendar_button_chosen == "cur day header":
                            calendar_current_day_header_color = selected_color
                        if calendar_button_chosen == "previous day":
                            calendar_previous_day_color = selected_color
                        if calendar_button_chosen == "pre day header":
                            calendar_previous_day_header_color = selected_color
                        if calendar_button_chosen == "next day":
                            calendar_next_day_color = selected_color
                        if calendar_button_chosen == "next day header":
                            calendar_next_day_header_color = selected_color
                        if calendar_button_chosen == "month pre/next":
                            calendar_month_color = selected_color
                        if calendar_button_chosen == "homework fol":
                            homework_fol_color = selected_color
                        if calendar_button_chosen == "chores fol":
                            chores_fol_color = selected_color
                        if calendar_button_chosen == "work fol":
                            work_fol_color = selected_color
                        if calendar_button_chosen == "misc fol":
                            misc_fol_color = selected_color
            elif event.type == pygame.KEYDOWN and input_active == "spoon_name":
                if event.key == pygame.K_RETURN:
                    # Update the spoon_name variable when Enter is pressed
                    spoon_name = spoon_name_input
                    spoon_name_input = ""  # Clear the input
                    input_active = False
                elif event.key == pygame.K_BACKSPACE:
                    # Remove the last character from the input
                    spoon_name_input = spoon_name_input[:-1]
                else:
                    # Add new characters to the input
                    spoon_name_input += event.unicode  
    
    remove_completed_tasks(tasks_to_remove)
    pygame.display.flip()

pygame.quit()
sys.exit()